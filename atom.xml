<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>xlfan&#39;s blog</title>
  
  
  <link href="https://xielingfan.github.io/atom.xml" rel="self"/>
  
  <link href="https://xielingfan.github.io/"/>
  <updated>2022-06-20T12:25:33.714Z</updated>
  <id>https://xielingfan.github.io/</id>
  
  <author>
    <name>xlfan</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>阿拉伯数字与中文的转换</title>
    <link href="https://xielingfan.github.io/2022/06/20/%E9%98%BF%E6%8B%89%E4%BC%AF%E6%95%B0%E5%AD%97%E4%B8%8E%E4%B8%AD%E6%96%87%E7%9A%84%E8%BD%AC%E6%8D%A2/"/>
    <id>https://xielingfan.github.io/2022/06/20/%E9%98%BF%E6%8B%89%E4%BC%AF%E6%95%B0%E5%AD%97%E4%B8%8E%E4%B8%AD%E6%96%87%E7%9A%84%E8%BD%AC%E6%8D%A2/</id>
    <published>2022-06-20T12:12:05.000Z</published>
    <updated>2022-06-20T12:25:33.714Z</updated>
    
    <content type="html"><![CDATA[<h1 id="问题一：中文数字转阿拉伯数字"><a href="#问题一：中文数字转阿拉伯数字" class="headerlink" title="问题一：中文数字转阿拉伯数字"></a>问题一：中文数字转阿拉伯数字</h1><h1 id="问题二：阿拉伯数字转中文数字"><a href="#问题二：阿拉伯数字转中文数字" class="headerlink" title="问题二：阿拉伯数字转中文数字"></a>问题二：阿拉伯数字转中文数字</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;问题一：中文数字转阿拉伯数字&quot;&gt;&lt;a href=&quot;#问题一：中文数字转阿拉伯数字&quot; class=&quot;headerlink&quot; title=&quot;问题一：中文数字转阿拉伯数字&quot;&gt;&lt;/a&gt;问题一：中文数字转阿拉伯数字&lt;/h1&gt;&lt;h1 id=&quot;问题二：阿拉伯数字转中文数字&quot;&gt;&lt;</summary>
      
    
    
    
    
    <category term="面试常见问题" scheme="https://xielingfan.github.io/tags/%E9%9D%A2%E8%AF%95%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer题解</title>
    <link href="https://xielingfan.github.io/2022/06/13/%E5%89%91%E6%8C%87offer%E9%A2%98%E8%A7%A3/"/>
    <id>https://xielingfan.github.io/2022/06/13/%E5%89%91%E6%8C%87offer%E9%A2%98%E8%A7%A3/</id>
    <published>2022-06-13T15:59:39.000Z</published>
    <updated>2022-06-13T16:04:09.505Z</updated>
    
    <content type="html"><![CDATA[<h4 id="剑指-Offer-03-数组中重复的数字"><a href="#剑指-Offer-03-数组中重复的数字" class="headerlink" title="剑指 Offer 03. 数组中重复的数字"></a><a href="https://leetcode.cn/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof/">剑指 Offer 03. 数组中重复的数字</a></h4><p>原地交换</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findRepeatNumber</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span>(nums[i] != i) &#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[i] == nums[nums[i]]) <span class="keyword">return</span> nums[i];</span><br><span class="line">                <span class="built_in">swap</span>(nums[i], nums[nums[i]]);</span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>如果题目改成数组大小为n， 数据范围为[1,n-1]， 可以使用二分求解，不修改原数组</p><h4 id="剑指-Offer-04-二维数组中的查找"><a href="#剑指-Offer-04-二维数组中的查找" class="headerlink" title="剑指 Offer 04. 二维数组中的查找"></a><a href="https://leetcode.cn/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof/">剑指 Offer 04. 二维数组中的查找</a></h4><p>法一： 每一行二分</p><p>法二：<strong>Z 字形查找</strong>（线性） 从数组右上角开始查找。如果当前元素大于目标值，说明当前元素的下边的所有元素都一定大于目标值，因此往下查找不可能找到目标值，往左查找可能找到目标值。如果当前元素小于目标值，说明当前元素的左边的所有元素都一定小于目标值，因此往左查找不可能找到目标值，往下查找可能找到目标值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">findNumberIn2DArray</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; matrix, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> m = matrix.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(!m) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">int</span> n = matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>, j = n<span class="number">-1</span>; i &lt; m &amp;&amp; j &gt;= <span class="number">0</span>; ) &#123;</span><br><span class="line">            <span class="keyword">if</span>(matrix[i][j] == target) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(matrix[i][j] &gt; target) j--;</span><br><span class="line">            <span class="keyword">else</span> i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="剑指-Offer-05-替换空格"><a href="#剑指-Offer-05-替换空格" class="headerlink" title="剑指 Offer 05. 替换空格"></a><a href="https://leetcode.cn/problems/ti-huan-kong-ge-lcof/">剑指 Offer 05. 替换空格</a></h4><p>原地修改， 扩容， 逆序遍历， 双指针</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">replaceSpace</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> oldLen = s.<span class="built_in">size</span>(), cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> c: s) </span><br><span class="line">            <span class="keyword">if</span>(c == <span class="string">&#x27; &#x27;</span>) cnt++;</span><br><span class="line">        <span class="type">int</span> newLen = oldLen + cnt*<span class="number">2</span>;</span><br><span class="line">        s.<span class="built_in">resize</span>(newLen);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = oldLen<span class="number">-1</span>, j = newLen<span class="number">-1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i] != <span class="string">&#x27; &#x27;</span>) s[j--] = s[i];</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                s[j--] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                s[j--] = <span class="string">&#x27;2&#x27;</span>;</span><br><span class="line">                s[j--] = <span class="string">&#x27;%&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;a</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="剑指-Offer-06-从尾到头打印链表"><a href="#剑指-Offer-06-从尾到头打印链表" class="headerlink" title="剑指 Offer 06. 从尾到头打印链表"></a><a href="https://leetcode.cn/problems/cong-wei-dao-tou-da-yin-lian-biao-lcof/">剑指 Offer 06. 从尾到头打印链表</a></h4><p>栈或递归</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">reversePrint</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">f</span>(head);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!head) <span class="keyword">return</span>;</span><br><span class="line">        <span class="built_in">f</span>(head-&gt;next);</span><br><span class="line">        res.<span class="built_in">push_back</span>(head-&gt;val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="剑指-Offer-07-重建二叉树"><a href="#剑指-Offer-07-重建二叉树" class="headerlink" title="剑指 Offer 07. 重建二叉树"></a><a href="https://leetcode.cn/problems/zhong-jian-er-cha-shu-lcof/">剑指 Offer 07. 重建二叉树</a></h4><p>递归， 利用unordered_map优化在中序中找根的过程</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; mp;</span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; preorder, vector&lt;<span class="type">int</span>&gt;&amp; inorder)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = preorder.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) mp[inorder[i]] = i;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">f</span>(preorder, inorder, <span class="number">0</span>, n<span class="number">-1</span>, <span class="number">0</span>, n<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode* <span class="title">f</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; preorder, vector&lt;<span class="type">int</span>&gt;&amp; inorder, <span class="type">int</span> pl, <span class="type">int</span> pr, <span class="type">int</span> il, <span class="type">int</span> ir)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pr &lt; pl) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="type">int</span> idx = mp[preorder[pl]];</span><br><span class="line">        <span class="keyword">auto</span> root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(inorder[idx]);</span><br><span class="line">        <span class="type">int</span> lNum = idx - il, rNum = ir - idx;</span><br><span class="line">        root-&gt;left = <span class="built_in">f</span>(preorder, inorder, pl+<span class="number">1</span>, pl+lNum, il, idx<span class="number">-1</span>);</span><br><span class="line">        root-&gt;right = <span class="built_in">f</span>(preorder, inorder, pr-rNum+<span class="number">1</span>, pr, idx+<span class="number">1</span>, ir);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="剑指-Offer-08-二叉树的下一个结点"><a href="#剑指-Offer-08-二叉树的下一个结点" class="headerlink" title="剑指 Offer 08. 二叉树的下一个结点"></a><a href="https://www.nowcoder.com/practice/9023a0c988684a53960365b889ceaf5e?tpId=265&tqId=39212&rp=1&ru=/exam/oj/ta&qru=/exam/oj/ta&sourceUrl=/exam/oj/ta?page=1&pageSize=50&search=8&tpId=13&type=265&difficulty=undefined&judgeStatus=undefined&tags=&title=8">剑指 Offer 08. 二叉树的下一个结点</a></h4><p>分类直接寻找</p><ol><li>如果给出的结点有右子节点，则最终要返回的下一个结点即右子树的最左下的结点</li><li>如果给出的结点无右子节点，且当前结点是其父节点的左子节点，则返回其父节点</li><li>如果给出的结点无右子节点，且当前结点是其父节点的右子节点，则先要沿着左上方父节点爬树，一直爬到当前结点是其父节点的左子节点为止，返回的就是这个父节点；或者没有满足上述情况的则返回为NULL</li></ol><p>代码中2、3可以合并</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeLinkNode* <span class="title">GetNext</span><span class="params">(TreeLinkNode* pNode)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pNode-&gt;right) &#123;</span><br><span class="line">            <span class="keyword">auto</span> t = pNode-&gt;right;</span><br><span class="line">            <span class="keyword">while</span>(t-&gt;left) t = t-&gt;left;</span><br><span class="line">            <span class="keyword">return</span> t;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(pNode-&gt;next &amp;&amp; pNode-&gt;next-&gt;left != pNode) pNode = pNode-&gt;next;</span><br><span class="line">        <span class="keyword">return</span> pNode-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="剑指-Offer-09-用两个栈实现队列"><a href="#剑指-Offer-09-用两个栈实现队列" class="headerlink" title="剑指 Offer 09. 用两个栈实现队列"></a><a href="https://leetcode.cn/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof/">剑指 Offer 09. 用两个栈实现队列</a></h4><p>push直接进栈1， pop从栈2取， 栈2为空时，将栈1推进栈2</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CQueue</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; stk1, stk2;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">CQueue</span>() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">appendTail</span><span class="params">(<span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">        stk1.<span class="built_in">push</span>(value);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">deleteHead</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span>(stk2.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">while</span>(stk1.<span class="built_in">size</span>()) &#123;</span><br><span class="line">                stk2.<span class="built_in">push</span>(stk1.<span class="built_in">top</span>());</span><br><span class="line">                stk1.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(stk2.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            res = stk2.<span class="built_in">top</span>();</span><br><span class="line">            stk2.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>拓展<a href="https://leetcode.cn/problems/implement-stack-using-queues/">225. 用队列实现栈</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyStack</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    <span class="built_in">MyStack</span>() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Push element x onto stack. */</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        q.<span class="built_in">push</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Removes the element on top of the stack and returns that element. */</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> s = q.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">while</span>(s-- &gt; <span class="number">1</span>) q.<span class="built_in">push</span>(q.<span class="built_in">front</span>()), q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="type">int</span> res = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">return</span> res; </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Get the top element. */</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> s = q.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">while</span>(s-- &gt; <span class="number">1</span>) q.<span class="built_in">push</span>(q.<span class="built_in">front</span>()), q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="type">int</span> res = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">push</span>(q.<span class="built_in">front</span>());</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">return</span> res; </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Returns whether the stack is empty. */</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> q.<span class="built_in">empty</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="剑指-Offer-10-I-斐波那契数列"><a href="#剑指-Offer-10-I-斐波那契数列" class="headerlink" title="剑指 Offer 10- I. 斐波那契数列"></a><a href="https://leetcode.cn/problems/fei-bo-na-qi-shu-lie-lcof/">剑指 Offer 10- I. 斐波那契数列</a></h4><p>dp， 递归效率低，除非记忆化</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> MOD = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">fib</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n &lt; <span class="number">2</span>) <span class="keyword">return</span> n;</span><br><span class="line">        <span class="type">int</span> a = <span class="number">0</span>, b = <span class="number">1</span>, c;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            c = (a + b) % MOD;</span><br><span class="line">            a = b;</span><br><span class="line">            b = c;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="剑指-Offer-10-II-青蛙跳台阶问题"><a href="#剑指-Offer-10-II-青蛙跳台阶问题" class="headerlink" title="剑指 Offer 10- II. 青蛙跳台阶问题"></a><a href="https://leetcode.cn/problems/qing-wa-tiao-tai-jie-wen-ti-lcof/">剑指 Offer 10- II. 青蛙跳台阶问题</a></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> MOD = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">numWays</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> a = <span class="number">1</span>, b = <span class="number">1</span>, c;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            c = (a + b) % MOD;</span><br><span class="line">            a = b;</span><br><span class="line">            b = c;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="剑指-Offer-11-旋转数组的最小数字"><a href="#剑指-Offer-11-旋转数组的最小数字" class="headerlink" title="剑指 Offer 11. 旋转数组的最小数字"></a><a href="https://leetcode.cn/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof/">剑指 Offer 11. 旋转数组的最小数字</a></h4><p>注意： 有重复数字</p><p>关键点： 如果正好将相同元素截断， 需要将数组末尾和首元素相同的部分删除</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; numbers)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> l = <span class="number">0</span>, r = numbers.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(r &gt; <span class="number">0</span> &amp;&amp; numbers[r] == numbers[<span class="number">0</span>]) r--;</span><br><span class="line">        <span class="keyword">while</span>(l &lt; r) &#123;</span><br><span class="line">            <span class="type">int</span> mid = l + r + <span class="number">1</span> &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(numbers[mid] &gt;= numbers[<span class="number">0</span>]) l = mid;</span><br><span class="line">            <span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> numbers[(l + <span class="number">1</span>) % numbers.<span class="built_in">size</span>()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="剑指-Offer-12-矩阵中的路径"><a href="#剑指-Offer-12-矩阵中的路径" class="headerlink" title="剑指 Offer 12. 矩阵中的路径"></a><a href="https://leetcode.cn/problems/ju-zhen-zhong-de-lu-jing-lcof/">剑指 Offer 12. 矩阵中的路径</a></h4><p>回溯</p><p>可以不开visit数组， 修改原数组即可， 注意恢复现场</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">char</span>&gt;&gt; g;</span><br><span class="line">    <span class="type">int</span> m, n;</span><br><span class="line">    <span class="type">int</span> dx[<span class="number">4</span>] = &#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;, dy[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>&#125;;</span><br><span class="line">    string s;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">exist</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; board, string word)</span> </span>&#123;</span><br><span class="line">        g = board;</span><br><span class="line">        m = g.<span class="built_in">size</span>(), n = g[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        s = word;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">dfs</span>(i, j, <span class="number">0</span>)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> u)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(g[x][y] != s[u]) <span class="keyword">return</span> <span class="literal">false</span>;    </span><br><span class="line">        <span class="keyword">if</span>(u == s.<span class="built_in">size</span>()<span class="number">-1</span>) <span class="keyword">return</span> <span class="literal">true</span>;    <span class="comment">//执行到这一行，说明位置u已经满足</span></span><br><span class="line"></span><br><span class="line">        <span class="type">char</span> t = g[x][y];</span><br><span class="line">        g[x][y] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">            <span class="type">int</span> a = x + dx[i], b = y + dy[i];</span><br><span class="line">            <span class="keyword">if</span>(a &lt; <span class="number">0</span> || a &gt;= m || b &lt; <span class="number">0</span> || b &gt;= n) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">dfs</span>(a, b, u+<span class="number">1</span>)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        g[x][y] = t;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="剑指-Offer-13-机器人的运动范围"><a href="#剑指-Offer-13-机器人的运动范围" class="headerlink" title="剑指 Offer 13. 机器人的运动范围"></a><a href="https://leetcode.cn/problems/ji-qi-ren-de-yun-dong-fan-wei-lcof/">剑指 Offer 13. 机器人的运动范围</a></h4><p>dfs或bfs，  只向右或向下搜索就可以， dfs代码短一些</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; vis;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">movingCount</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        vis = vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;(m, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n));</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dfs</span>(<span class="number">0</span>, <span class="number">0</span>, m, n, k);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> m, <span class="type">int</span> n, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(vis[x][y] || <span class="built_in">get</span>(x) + <span class="built_in">get</span>(y) &gt; k) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">1</span>;</span><br><span class="line">        vis[x][y] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(x &lt; m<span class="number">-1</span>) res += <span class="built_in">dfs</span>(x+<span class="number">1</span>, y, m, n, k);</span><br><span class="line">        <span class="keyword">if</span>(y &lt; n<span class="number">-1</span>) res += <span class="built_in">dfs</span>(x, y+<span class="number">1</span>, m, n, k);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(x) &#123;</span><br><span class="line">            res += x%<span class="number">10</span>;</span><br><span class="line">            x /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="剑指-Offer-14-I-剪绳子"><a href="#剑指-Offer-14-I-剪绳子" class="headerlink" title="剑指 Offer 14- I. 剪绳子"></a><a href="https://leetcode.cn/problems/jian-sheng-zi-lcof/">剑指 Offer 14- I. 剪绳子</a></h4><p>dp</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">cuttingRope</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">f</span><span class="params">(n+<span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt; i; j++) &#123;</span><br><span class="line">                f[i] = <span class="built_in">max</span>(f[i], <span class="built_in">max</span>(j*(i-j), j*f[i-j]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>数学： n &gt;&#x3D; 4一定可以拆成两个数更优， 而1没有贡献， 所以应该把n分成若干2或3</p><p>3 * 3 &gt; 2 * 2 * 2，所以3的优先级更高</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">cuttingRope</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n &lt; <span class="number">4</span>) <span class="keyword">return</span> n<span class="number">-1</span>;</span><br><span class="line">        <span class="type">int</span> a = n / <span class="number">3</span>, b = n%<span class="number">3</span>;</span><br><span class="line">        <span class="keyword">if</span>(b == <span class="number">0</span>) <span class="keyword">return</span> <span class="built_in">pow</span>(<span class="number">3</span>, a);</span><br><span class="line">        <span class="keyword">if</span>(b == <span class="number">1</span>) <span class="keyword">return</span> <span class="built_in">pow</span>(<span class="number">3</span>, a<span class="number">-1</span>) * <span class="number">4</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">pow</span>(<span class="number">3</span>, a) * <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="剑指-Offer-14-II-剪绳子-II"><a href="#剑指-Offer-14-II-剪绳子-II" class="headerlink" title="剑指 Offer 14- II. 剪绳子 II"></a><a href="https://leetcode.cn/problems/jian-sheng-zi-ii-lcof/">剑指 Offer 14- II. 剪绳子 II</a></h4><p>快速幂</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> MOD = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">cuttingRope</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n &lt; <span class="number">4</span>) <span class="keyword">return</span> n<span class="number">-1</span>;</span><br><span class="line">        <span class="type">int</span> a = n / <span class="number">3</span>, b = n%<span class="number">3</span>;</span><br><span class="line">        <span class="keyword">if</span>(b == <span class="number">0</span>) <span class="keyword">return</span> <span class="built_in">qmi</span>(<span class="number">3</span>, a);</span><br><span class="line">        <span class="keyword">if</span>(b == <span class="number">1</span>) <span class="keyword">return</span> <span class="built_in">qmi</span>(<span class="number">3</span>, a<span class="number">-1</span>) * <span class="number">4</span> % MOD;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">qmi</span>(<span class="number">3</span>, a) * <span class="number">2</span> % MOD;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">qmi</span><span class="params">(<span class="type">long</span> <span class="type">long</span> x, <span class="type">long</span> <span class="type">long</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> res = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(k) &#123;</span><br><span class="line">            <span class="keyword">if</span>(k&amp;<span class="number">1</span>) res = res * x % MOD;</span><br><span class="line">            x = (<span class="type">long</span> <span class="type">long</span>)x * x % MOD;</span><br><span class="line">            k &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="剑指-Offer-15-二进制中1的个数"><a href="#剑指-Offer-15-二进制中1的个数" class="headerlink" title="剑指 Offer 15. 二进制中1的个数"></a><a href="https://leetcode.cn/problems/er-jin-zhi-zhong-1de-ge-shu-lcof/">剑指 Offer 15. 二进制中1的个数</a></h4><p>lowbit</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">hammingWeight</span><span class="params">(<span class="type">uint32_t</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(n) &#123;</span><br><span class="line">            res++;</span><br><span class="line">            n -= n&amp;-n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="剑指-Offer-16-数值的整数次方"><a href="#剑指-Offer-16-数值的整数次方" class="headerlink" title="剑指 Offer 16. 数值的整数次方"></a><a href="https://leetcode.cn/problems/shu-zhi-de-zheng-shu-ci-fang-lcof/">剑指 Offer 16. 数值的整数次方</a></h4><p>快速幂， 注意考虑指数为负数的情况</p><p><strong>特别注意</strong>： -2 ^ 31取反赋值给int后， 还是等于-2 ^ 31, int最大正数是 2 ^ 31 - 1。 所以要用long long 来存去反后的值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">myPow</span><span class="params">(<span class="type">double</span> x, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">bool</span> flag = n &lt; <span class="number">0</span>;</span><br><span class="line">        <span class="type">double</span> res = <span class="number">1</span>;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> m = <span class="built_in">abs</span>(n);</span><br><span class="line">        <span class="keyword">while</span>(m) &#123;</span><br><span class="line">            <span class="keyword">if</span>(m&amp;<span class="number">1</span>) res *= x;</span><br><span class="line">            x *= x;</span><br><span class="line">            m &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag) res = <span class="number">1</span> / res;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="剑指-Offer-17-打印从1到最大的n位数"><a href="#剑指-Offer-17-打印从1到最大的n位数" class="headerlink" title="剑指 Offer 17. 打印从1到最大的n位数"></a><a href="https://leetcode.cn/problems/da-yin-cong-1dao-zui-da-de-nwei-shu-lcof/">剑指 Offer 17. 打印从1到最大的n位数</a></h4><p>隐藏的坑： 注意大数问题</p><p>全排列</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">printNumbers</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">dfs</span>(<span class="number">0</span>, n, <span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> n, string s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(u == n) &#123;</span><br><span class="line">            <span class="keyword">if</span>(s != <span class="string">&quot;&quot;</span>) cout &lt;&lt; s &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="type">char</span> c = <span class="string">&#x27;0&#x27;</span> + i;</span><br><span class="line">            <span class="keyword">if</span>(!i) &#123;</span><br><span class="line">                <span class="keyword">if</span>(s != <span class="string">&quot;&quot;</span>) <span class="built_in">dfs</span>(u+<span class="number">1</span>, n, s+c);</span><br><span class="line">                <span class="keyword">else</span> <span class="built_in">dfs</span>(u+<span class="number">1</span>, n, s);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">dfs</span>(u+<span class="number">1</span>, n, s+c);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="剑指-Offer-18-删除链表的节点"><a href="#剑指-Offer-18-删除链表的节点" class="headerlink" title="剑指 Offer 18. 删除链表的节点"></a><a href="https://leetcode.cn/problems/shan-chu-lian-biao-de-jie-dian-lcof/">剑指 Offer 18. 删除链表的节点</a></h4><p>leetcode题目与原题不一致， 原题与237类似， O(1)时间删除节点</p><p><a href="https://leetcode.cn/problems/delete-node-in-a-linked-list/">237. 删除链表中的节点</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">deleteNode</span><span class="params">(ListNode* node)</span> </span>&#123;</span><br><span class="line">        node-&gt;val = node-&gt;next-&gt;val;</span><br><span class="line">        node-&gt;next = node-&gt;next-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="困难-剑指-Offer-19-正则表达式匹配"><a href="#困难-剑指-Offer-19-正则表达式匹配" class="headerlink" title="*(困难)剑指 Offer 19. 正则表达式匹配"></a><a href="https://leetcode.cn/problems/zheng-ze-biao-da-shi-pi-pei-lcof/">*(困难)剑指 Offer 19. 正则表达式匹配</a></h4><p>dp</p><ul><li>下一个字符是*， 先跳到下一个字符， 两个字符一起处理</li><li>不是a*形式，需要匹配</li><li>是a*形式， 可以是0个a， 也可以用1个以上</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isMatch</span><span class="params">(string s, string p)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> m = s.<span class="built_in">size</span>(), n = p.<span class="built_in">size</span>();</span><br><span class="line">        s = <span class="string">&#x27; &#x27;</span> + s, p = <span class="string">&#x27; &#x27;</span> + p;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt; <span class="built_in">f</span>(m+<span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt;(n+<span class="number">1</span>));</span><br><span class="line">        f[<span class="number">0</span>][<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(j+<span class="number">1</span> &lt;= n &amp;&amp; p[j+<span class="number">1</span>] == <span class="string">&#x27;*&#x27;</span>) <span class="keyword">continue</span>;    <span class="comment">//下一个字符是*， 先跳到下一个字符， 两个字符一起处理</span></span><br><span class="line">                <span class="keyword">if</span>(i &amp;&amp; p[j] != <span class="string">&#x27;*&#x27;</span>) f[i][j] = f[i<span class="number">-1</span>][j<span class="number">-1</span>] &amp;&amp; (s[i] == p[j] || p[j] == <span class="string">&#x27;.&#x27;</span>);    <span class="comment">// 不是*，需要匹配</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(p[j] == <span class="string">&#x27;*&#x27;</span>) f[i][j] = f[i][j<span class="number">-2</span>] ||   <span class="comment">// 0</span></span><br><span class="line">                    (i &amp;&amp; f[i<span class="number">-1</span>][j] &amp;&amp; (s[i] == p[j<span class="number">-1</span>] || p[j<span class="number">-1</span>] == <span class="string">&#x27;.&#x27;</span>));    <span class="comment">// 1+</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f[m][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>类似题目<a href="https://leetcode.cn/problems/wildcard-matching/">44. 通配符匹配</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isMatch</span><span class="params">(string s, string p)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> m = s.<span class="built_in">size</span>(), n = p.<span class="built_in">size</span>();</span><br><span class="line">        s = <span class="string">&#x27; &#x27;</span> + s, p = <span class="string">&#x27; &#x27;</span> + p;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt; <span class="built_in">f</span>(m+<span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt;(n+<span class="number">1</span>));</span><br><span class="line">        f[<span class="number">0</span>][<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">                <span class="type">int</span> x = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(p[j] == <span class="string">&#x27;?&#x27;</span>) f[i][j] = i &amp;&amp; f[i<span class="number">-1</span>][j<span class="number">-1</span>];</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(p[j] == <span class="string">&#x27;*&#x27;</span>) f[i][j] = f[i][j<span class="number">-1</span>] || (i &amp;&amp; f[i<span class="number">-1</span>][j]);</span><br><span class="line">                <span class="keyword">else</span> f[i][j] = i &amp;&amp; f[i<span class="number">-1</span>][j<span class="number">-1</span>] &amp;&amp; s[i] == p[j];</span><br><span class="line">                <span class="type">int</span> y = <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f[m][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="剑指-Offer-20-表示数值的字符串"><a href="#剑指-Offer-20-表示数值的字符串" class="headerlink" title="*剑指 Offer 20. 表示数值的字符串"></a><a href="https://leetcode.cn/problems/biao-shi-shu-zhi-de-zi-fu-chuan-lcof/">*剑指 Offer 20. 表示数值的字符串</a></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isNumber</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> u = <span class="number">0</span>, n = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">while</span>(u &lt; n &amp;&amp; s[u] == <span class="string">&#x27; &#x27;</span>) u++;</span><br><span class="line">        <span class="type">bool</span> flag = <span class="built_in">isInt</span>(s, u);</span><br><span class="line">        <span class="keyword">if</span>(u &lt; n &amp;&amp; s[u] == <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">            u++;</span><br><span class="line">            flag = <span class="built_in">isUnsignedInt</span>(s, u) || flag;        <span class="comment">// xxx.   xxx.xxx   .xxx都是合法小数, 注意：isUnsignedInt(s, u)一定不要放到后面，可能会不执行</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> x = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(u &lt; n &amp;&amp; (s[u] == <span class="string">&#x27;e&#x27;</span> || s[u] == <span class="string">&#x27;E&#x27;</span>)) &#123;</span><br><span class="line">            u++;</span><br><span class="line">            flag = <span class="built_in">isInt</span>(s, u) &amp;&amp; flag;        <span class="comment">// 必须是xxxexxx形式</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(u &lt; n &amp;&amp; s[u] == <span class="string">&#x27; &#x27;</span>) u++;</span><br><span class="line">        <span class="keyword">return</span> flag &amp;&amp; u == n;</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isInt</span><span class="params">(string&amp; s, <span class="type">int</span>&amp; u)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(u == s.<span class="built_in">size</span>()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(s[u] == <span class="string">&#x27;+&#x27;</span> || s[u] == <span class="string">&#x27;-&#x27;</span>) u++;</span><br><span class="line">        <span class="type">int</span> t = u;</span><br><span class="line">        <span class="keyword">while</span>(u &lt; s.<span class="built_in">size</span>() &amp;&amp; <span class="built_in">isdigit</span>(s[u])) u++;</span><br><span class="line">        <span class="keyword">return</span> u != t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isUnsignedInt</span><span class="params">(string&amp; s, <span class="type">int</span> &amp; u)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(u == s.<span class="built_in">size</span>()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">int</span> t = u;</span><br><span class="line">        <span class="keyword">while</span>(u &lt; s.<span class="built_in">size</span>() &amp;&amp; <span class="built_in">isdigit</span>(s[u])) u++;</span><br><span class="line">        <span class="keyword">return</span> u != t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="剑指-Offer-21-调整数组顺序使奇数位于偶数前面"><a href="#剑指-Offer-21-调整数组顺序使奇数位于偶数前面" class="headerlink" title="剑指 Offer 21. 调整数组顺序使奇数位于偶数前面"></a><a href="https://leetcode.cn/problems/diao-zheng-shu-zu-shun-xu-shi-qi-shu-wei-yu-ou-shu-qian-mian-lcof/">剑指 Offer 21. 调整数组顺序使奇数位于偶数前面</a></h4><p>双指针</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">exchange</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]%<span class="number">2</span>) <span class="built_in">swap</span>(nums[i], nums[j++]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="剑指-Offer-22-链表中倒数第k个节点"><a href="#剑指-Offer-22-链表中倒数第k个节点" class="headerlink" title="剑指 Offer 22. 链表中倒数第k个节点"></a><a href="https://leetcode.cn/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/">剑指 Offer 22. 链表中倒数第k个节点</a></h4><p>快慢指针</p><p>两个指针p、q指向head， q先向后移动k， 然后一起移动，q移动到空节点，q就是倒数第k个节点</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">getKthFromEnd</span><span class="params">(ListNode* head, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> p = head, q = head;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; k; i++) q = q-&gt;next;</span><br><span class="line">        <span class="keyword">while</span>(q) q = q-&gt;next, p = p-&gt;next;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="剑指-Offer-23-链表中环的入口结点"><a href="#剑指-Offer-23-链表中环的入口结点" class="headerlink" title="*剑指 Offer 23.  链表中环的入口结点"></a><a href="https://leetcode.cn/problems/linked-list-cycle-ii/">*剑指 Offer 23.  链表中环的入口结点</a></h4><p>最简单的方法： 利用哈希表 或 算出环的长度， 然后类似上一题的做法</p><p>常规方法：快慢指针 O(n+n)</p><ul><li>slow和fast相遇后，让 slow返回起点，fast待在原地不动，然后两个指针每次分别走一步，当相遇时，相遇点就是环的入口</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">slow = x + y</span><br><span class="line">fast = x + y + n*C</span><br><span class="line">slow*<span class="number">2</span> = fast</span><br><span class="line"></span><br><span class="line">推出：   x + y = n*<span class="built_in">C</span>   (n倍周长)</span><br></pre></td></tr></table></figure><ul><li>slow &#x3D; x + y    fast &#x3D; x + nC(周长) + y &#x3D; 2x + 2y</li><li>nC &#x3D; x + y   从c再走x就是b</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode *detectCycle(ListNode *head) &#123;</span><br><span class="line">        if(!head) return NULL;</span><br><span class="line">        ListNode*p = head, *q = head, *meet = NULL;</span><br><span class="line">        while(p-&gt;next &amp;&amp; p-&gt;next-&gt;next) &#123;</span><br><span class="line">            p = p-&gt;next-&gt;next;</span><br><span class="line">            q = q-&gt;next;</span><br><span class="line">            if(p == q) &#123;</span><br><span class="line">                meet = p;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if(meet) &#123;</span><br><span class="line">            p = head;</span><br><span class="line">            while(p != meet) p = p-&gt;next, meet = meet-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        return meet;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>取巧： O(n)   堆的地址从低到高，链表内存是顺序申请的，如果有环，head一定大于或等于head-&gt;next</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">detectCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(head) &#123;</span><br><span class="line">            <span class="keyword">if</span>(!<span class="built_in">less</span>&lt;ListNode *&gt;()(head, head-&gt;next)) <span class="keyword">return</span> head-&gt;next;</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="剑指-Offer-24-反转链表"><a href="#剑指-Offer-24-反转链表" class="headerlink" title="剑指 Offer 24. 反转链表"></a><a href="https://leetcode.cn/problems/fan-zhuan-lian-biao-lcof/">剑指 Offer 24. 反转链表</a></h4><p>头插法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">auto</span> p = head;</span><br><span class="line">        <span class="keyword">while</span>(p) &#123;</span><br><span class="line">            <span class="keyword">auto</span> q = p-&gt;next;</span><br><span class="line">            p-&gt;next = dummy-&gt;next;</span><br><span class="line">            dummy-&gt;next = p;</span><br><span class="line">            p = q;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="剑指-Offer-25-合并两个排序的链表"><a href="#剑指-Offer-25-合并两个排序的链表" class="headerlink" title="剑指 Offer 25. 合并两个排序的链表"></a><a href="https://leetcode.cn/problems/he-bing-liang-ge-pai-xu-de-lian-biao-lcof/">剑指 Offer 25. 合并两个排序的链表</a></h4><p>归并</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">auto</span> p = dummy;</span><br><span class="line">        <span class="keyword">while</span>(l1 &amp;&amp; l2) &#123;</span><br><span class="line">            <span class="keyword">if</span>(l1-&gt;val &lt; l2-&gt;val) p = p-&gt;next = <span class="keyword">new</span> <span class="built_in">ListNode</span>(l1-&gt;val), l1 = l1-&gt;next;</span><br><span class="line">            <span class="keyword">else</span> p = p-&gt;next = <span class="keyword">new</span> <span class="built_in">ListNode</span>(l2-&gt;val), l2 = l2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(l1) p = p-&gt;next = <span class="keyword">new</span> <span class="built_in">ListNode</span>(l1-&gt;val), l1 = l1-&gt;next;</span><br><span class="line">        <span class="keyword">while</span>(l2) p = p-&gt;next = <span class="keyword">new</span> <span class="built_in">ListNode</span>(l2-&gt;val), l2 = l2-&gt;next;</span><br><span class="line">        <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="剑指-Offer-26-树的子结构"><a href="#剑指-Offer-26-树的子结构" class="headerlink" title="*剑指 Offer 26. 树的子结构"></a><a href="https://leetcode.cn/problems/shu-de-zi-jie-gou-lcof/">*剑指 Offer 26. 树的子结构</a></h4><p>借助辅助函数， check函数允许空树是另一个树的子结构</p><ol><li>找到A-&gt;val &#x3D;&#x3D; B-&gt;val</li><li>check(A-&gt;left, B-&gt;left)和check(A-&gt;right, B-&gt;right)</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isSubStructure</span><span class="params">(TreeNode* A, TreeNode* B)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!A &amp;&amp; !B) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(!A || !B) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(A-&gt;val == B-&gt;val) <span class="keyword">if</span>(<span class="built_in">check</span>(A-&gt;left, B-&gt;left) &amp;&amp; <span class="built_in">check</span>(A-&gt;right, B-&gt;right)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">isSubStructure</span>(A-&gt;left, B) || <span class="built_in">isSubStructure</span>(A-&gt;right, B);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(TreeNode* A, TreeNode* B)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!B) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> A &amp;&amp; (A-&gt;val == B-&gt;val) &amp;&amp; <span class="built_in">check</span>(A-&gt;left, B-&gt;left) &amp;&amp; <span class="built_in">check</span>(A-&gt;right, B-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>类似题目<a href="https://leetcode.cn/problems/subtree-of-another-tree/">572. 另一棵树的子树</a> </p><p>辅助函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isSubtree</span><span class="params">(TreeNode* root, TreeNode* subRoot)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> !subRoot;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">check</span>(root, subRoot)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">isSubtree</span>(root-&gt;left, subRoot) || <span class="built_in">isSubtree</span>(root-&gt;right, subRoot);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断两棵树是否相等</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(TreeNode* a, TreeNode* b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!a &amp;&amp; !b) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> a &amp;&amp; b &amp;&amp; a-&gt;val == b-&gt;val &amp;&amp; <span class="built_in">check</span>(a-&gt;left, b-&gt;left) &amp;&amp; <span class="built_in">check</span>(a-&gt;right, b-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="剑指-Offer-27-二叉树的镜像"><a href="#剑指-Offer-27-二叉树的镜像" class="headerlink" title="剑指 Offer 27. 二叉树的镜像"></a><a href="https://leetcode.cn/problems/er-cha-shu-de-jing-xiang-lcof/">剑指 Offer 27. 二叉树的镜像</a></h4><p>递归写法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">mirrorTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">auto</span> l = root-&gt;left, r = root-&gt;right;</span><br><span class="line">        root-&gt;left = r;</span><br><span class="line">        root-&gt;right = l;</span><br><span class="line">        <span class="built_in">mirrorTree</span>(l);</span><br><span class="line">        <span class="built_in">mirrorTree</span>(r);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>循环写法 (层次遍历)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">mirrorTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        queue&lt;TreeNode*&gt; q;</span><br><span class="line">        q.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span>(q.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">auto</span> t = q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">auto</span> l = t-&gt;left;</span><br><span class="line">            t-&gt;left = t-&gt;right;</span><br><span class="line">            t-&gt;right = l;</span><br><span class="line">            <span class="keyword">if</span>(t-&gt;left) q.<span class="built_in">push</span>(t-&gt;left);</span><br><span class="line">            <span class="keyword">if</span>(t-&gt;right) q.<span class="built_in">push</span>(t-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="剑指-Offer-28-对称的二叉树"><a href="#剑指-Offer-28-对称的二叉树" class="headerlink" title="剑指 Offer 28. 对称的二叉树"></a><a href="https://leetcode.cn/problems/dui-cheng-de-er-cha-shu-lcof/">剑指 Offer 28. 对称的二叉树</a></h4><p>递归， 辅助函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isSymmetric</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">check</span>(root-&gt;left, root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(TreeNode* l, TreeNode* r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!l &amp;&amp; !r) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> l &amp;&amp; r &amp;&amp; l-&gt;val == r-&gt;val &amp;&amp; <span class="built_in">check</span>(l-&gt;left, r-&gt;right) &amp;&amp; <span class="built_in">check</span>(l-&gt;right, r-&gt;left);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="剑指-Offer-29-顺时针打印矩阵"><a href="#剑指-Offer-29-顺时针打印矩阵" class="headerlink" title="剑指 Offer 29. 顺时针打印矩阵"></a><a href="https://leetcode.cn/problems/shun-shi-zhen-da-yin-ju-zhen-lcof/">剑指 Offer 29. 顺时针打印矩阵</a></h4><p>按照右下左上的顺序模拟， 走到头或者已遍历的元素就换下一个方向</p><p>循环总次数是m * n</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">spiralOrder</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> m = matrix.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(!m) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        <span class="type">int</span> n = matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt; <span class="built_in">st</span>(m, <span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt;(n));</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> dx[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;, dy[<span class="number">4</span>] = &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>, x = <span class="number">0</span>, y = <span class="number">0</span>, d = <span class="number">0</span>; i &lt; m*n; i++) &#123;</span><br><span class="line">            st[x][y] = <span class="literal">true</span>;</span><br><span class="line">            res.<span class="built_in">push_back</span>(matrix[x][y]);</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> a = x + dx[d], b = y + dy[d];</span><br><span class="line">            <span class="keyword">if</span>(a &lt; <span class="number">0</span> || a &gt;= m || b &lt; <span class="number">0</span> || b &gt;= n || st[a][b]) &#123;</span><br><span class="line">                d = (d+<span class="number">1</span>)%<span class="number">4</span>;</span><br><span class="line">                a = x + dx[d];</span><br><span class="line">                b = y + dy[d];</span><br><span class="line">            &#125;</span><br><span class="line">            x = a, y = b;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="剑指-Offer-30-包含min函数的栈"><a href="#剑指-Offer-30-包含min函数的栈" class="headerlink" title="*剑指 Offer 30. 包含min函数的栈"></a><a href="https://leetcode.cn/problems/bao-han-minhan-shu-de-zhan-lcof/">*剑指 Offer 30. 包含min函数的栈</a></h4><p>常规思路： 辅助栈， 空间复杂度O(n)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MinStack</span> &#123;</span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; stk1, stk2;</span><br><span class="line">    <span class="built_in">MinStack</span>() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        stk1.<span class="built_in">push</span>(val);</span><br><span class="line">        <span class="keyword">if</span>(stk2.<span class="built_in">size</span>() &amp;&amp; stk2.<span class="built_in">top</span>() &lt; val) stk2.<span class="built_in">push</span>(stk2.<span class="built_in">top</span>());</span><br><span class="line">        <span class="keyword">else</span> stk2.<span class="built_in">push</span>(val);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        stk1.<span class="built_in">pop</span>();</span><br><span class="line">        stk2.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> stk1.<span class="built_in">top</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getMin</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> stk2.<span class="built_in">top</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>无额外空间的做法， 保存差值，即保存： <strong>将要入栈元素与当前栈中最小值的差值</strong>， diff  &gt; 0说明入栈的元素不是新的最小值， 反之是最小值。</p><p><strong>难点</strong>： </p><ul><li>pop操作后，要知道之前的最小值</li></ul><p>保存当前值与上一个最小值的关系， 如果当前值不是最小值， 那么pop不影响最小值； 如果当前值是最小值， 那么还知道当前值与上一个最小值的关系，就可以得出上一个最小值。</p><ul><li>要维护什么关系呢？ 因为我们想判断当前值是不是最小值， 所以可以做差， 通过差的正负，可以得知当前值与上一个最小值的大小。</li></ul><p><strong>坑</strong>：要用long long ，维护差值时int - int会爆int</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MinStack</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    stack&lt;LL&gt; stk;</span><br><span class="line">    LL minV;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** initialize your data structure here. */</span></span><br><span class="line">    <span class="built_in">MinStack</span>() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(stk.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            stk.<span class="built_in">push</span>(<span class="number">0</span>);</span><br><span class="line">            minV = x;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            LL diff = x - minV;</span><br><span class="line">            stk.<span class="built_in">push</span>(diff);</span><br><span class="line">            minV = diff &gt; <span class="number">0</span> ? minV : x;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        minV = stk.<span class="built_in">top</span>() &gt; <span class="number">0</span> ? minV : minV - stk.<span class="built_in">top</span>();</span><br><span class="line">        stk.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> stk.<span class="built_in">top</span>() &gt; <span class="number">0</span> ? stk.<span class="built_in">top</span>() + minV : minV;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">min</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> minV;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="剑指-Offer-31-栈的压入、弹出序列"><a href="#剑指-Offer-31-栈的压入、弹出序列" class="headerlink" title="剑指 Offer 31. 栈的压入、弹出序列"></a><a href="https://leetcode.cn/problems/zhan-de-ya-ru-dan-chu-xu-lie-lcof/">剑指 Offer 31. 栈的压入、弹出序列</a></h4><p>用一个栈模拟</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">validateStackSequences</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; pushed, vector&lt;<span class="type">int</span>&gt;&amp; popped)</span> </span>&#123;</span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; stk;</span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>, n = pushed.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> x: popped) &#123;</span><br><span class="line">            <span class="keyword">while</span>(i &lt; n &amp;&amp; (stk.<span class="built_in">empty</span>() || stk.<span class="built_in">top</span>() != x)) stk.<span class="built_in">push</span>(pushed[i++]);</span><br><span class="line">            <span class="keyword">if</span>(stk.<span class="built_in">top</span>() != x) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            stk.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="剑指-Offer-32-I-从上到下打印二叉树"><a href="#剑指-Offer-32-I-从上到下打印二叉树" class="headerlink" title="剑指 Offer 32 - I. 从上到下打印二叉树"></a><a href="https://leetcode.cn/problems/cong-shang-dao-xia-da-yin-er-cha-shu-lcof/">剑指 Offer 32 - I. 从上到下打印二叉树</a></h4><p>层序遍历、广搜</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">levelOrder</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        queue&lt;TreeNode*&gt; q;</span><br><span class="line">        q.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span>(q.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">auto</span> t = q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            res.<span class="built_in">push_back</span>(t-&gt;val);</span><br><span class="line">            <span class="keyword">if</span>(t-&gt;left) q.<span class="built_in">push</span>(t-&gt;left);</span><br><span class="line">            <span class="keyword">if</span>(t-&gt;right) q.<span class="built_in">push</span>(t-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="剑指-Offer-32-II-从上到下打印二叉树-II"><a href="#剑指-Offer-32-II-从上到下打印二叉树-II" class="headerlink" title="剑指 Offer 32 - II. 从上到下打印二叉树 II"></a><a href="https://leetcode.cn/problems/cong-shang-dao-xia-da-yin-er-cha-shu-ii-lcof/">剑指 Offer 32 - II. 从上到下打印二叉树 II</a></h4><p>记录每层的数量</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">levelOrder</span>(TreeNode* root) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">        queue&lt;TreeNode*&gt; q;</span><br><span class="line">        q.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span>(q.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="type">int</span> len = q.<span class="built_in">size</span>();</span><br><span class="line">            vector&lt;<span class="type">int</span>&gt; layer;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">                <span class="keyword">auto</span> t = q.<span class="built_in">front</span>();</span><br><span class="line">                q.<span class="built_in">pop</span>();</span><br><span class="line">                layer.<span class="built_in">push_back</span>(t-&gt;val);</span><br><span class="line">                <span class="keyword">if</span>(t-&gt;left) q.<span class="built_in">push</span>(t-&gt;left);</span><br><span class="line">                <span class="keyword">if</span>(t-&gt;right) q.<span class="built_in">push</span>(t-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">            res.<span class="built_in">push_back</span>(layer);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="剑指-Offer-32-III-从上到下打印二叉树-III"><a href="#剑指-Offer-32-III-从上到下打印二叉树-III" class="headerlink" title="剑指 Offer 32 - III. 从上到下打印二叉树 III"></a><a href="https://leetcode.cn/problems/cong-shang-dao-xia-da-yin-er-cha-shu-iii-lcof/">剑指 Offer 32 - III. 从上到下打印二叉树 III</a></h4><p>偶数层反转</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">levelOrder</span>(TreeNode* root) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">        queue&lt;TreeNode*&gt; q;</span><br><span class="line">        q.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="type">int</span> k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(q.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="type">int</span> len = q.<span class="built_in">size</span>();</span><br><span class="line">            vector&lt;<span class="type">int</span>&gt; layer;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">                <span class="keyword">auto</span> t = q.<span class="built_in">front</span>();</span><br><span class="line">                q.<span class="built_in">pop</span>();</span><br><span class="line">                layer.<span class="built_in">push_back</span>(t-&gt;val);</span><br><span class="line">                <span class="keyword">if</span>(t-&gt;left) q.<span class="built_in">push</span>(t-&gt;left);</span><br><span class="line">                <span class="keyword">if</span>(t-&gt;right) q.<span class="built_in">push</span>(t-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>((k++)%<span class="number">2</span>) <span class="built_in">reverse</span>(layer.<span class="built_in">begin</span>(), layer.<span class="built_in">end</span>());</span><br><span class="line">            res.<span class="built_in">push_back</span>(layer);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="剑指-Offer-33-二叉搜索树的后序遍历序列"><a href="#剑指-Offer-33-二叉搜索树的后序遍历序列" class="headerlink" title="*剑指 Offer 33. 二叉搜索树的后序遍历序列"></a><a href="https://leetcode.cn/problems/er-cha-sou-suo-shu-de-hou-xu-bian-li-xu-lie-lcof/">*剑指 Offer 33. 二叉搜索树的后序遍历序列</a></h4><p>法一： 递归</p><p>检查左全部小于根， 右全部大于根</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">verifyPostorder</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; postorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">check</span>(postorder, <span class="number">0</span>, postorder.<span class="built_in">size</span>()<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; postorder, <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l &gt;= r) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="type">int</span> i = l;</span><br><span class="line">        <span class="keyword">while</span>(postorder[i] &lt; postorder[r]) i++;</span><br><span class="line">        <span class="type">int</span> j = i;</span><br><span class="line">        <span class="keyword">while</span>(postorder[j] &gt; postorder[r]) j++;</span><br><span class="line">        <span class="keyword">return</span> j == r &amp;&amp; <span class="built_in">check</span>(postorder, l, i<span class="number">-1</span>) &amp;&amp; <span class="built_in">check</span>(postorder, i, r<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>法二： 单调栈*</p><p>后序遍历 left -&gt; right-&gt; root</p><p>从右向左逆序看 root-&gt;right-&gt;left</p><p>往右子树遍历的过程，value是越来越大的，一旦出现了value小于栈顶元素value的时候，就表示要开始进入左子树了。但是这个左子树是从哪个节点开始的呢？</p><p>单调栈帮我们记录了这些节点，只要栈顶元素还比当前节点大，就表示还是右子树，要移除，因为我们要找到这个左孩子节点直接连接的父节点，也就是找到这个子树的根，只要栈顶元素还大于当前节点，就要一直弹出，直到栈顶元素小于节点，或者栈为空。栈顶的上一个元素就是子树节点的根。</p><p>之后的左子树的每个节点，都要比子树的根要小，才能满足二叉搜索树，否则就不是二叉搜索树。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">verifyPostorder</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; postorder)</span> </span>&#123;</span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; stk;</span><br><span class="line">        <span class="type">int</span> root = INT_MAX;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = postorder.<span class="built_in">size</span>()<span class="number">-1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="type">int</span> x = postorder[i];</span><br><span class="line">            <span class="keyword">if</span>(x &gt; root) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">while</span>(stk.<span class="built_in">size</span>() &amp;&amp; stk.<span class="built_in">top</span>() &gt; x) &#123;</span><br><span class="line">                root = stk.<span class="built_in">top</span>();</span><br><span class="line">                stk.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            stk.<span class="built_in">push</span>(x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="剑指-Offer-34-二叉树中和为某一值的路径"><a href="#剑指-Offer-34-二叉树中和为某一值的路径" class="headerlink" title="剑指 Offer 34. 二叉树中和为某一值的路径"></a><a href="https://leetcode.cn/problems/er-cha-shu-zhong-he-wei-mou-yi-zhi-de-lu-jing-lcof/">剑指 Offer 34. 二叉树中和为某一值的路径</a></h4><p>回溯</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">pathSum</span>(TreeNode* root, <span class="type">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> res;</span><br><span class="line">        <span class="built_in">dfs</span>(root, target);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(TreeNode* root, <span class="type">int</span> cur)</span> </span>&#123;</span><br><span class="line">        path.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">        cur -= root-&gt;val;</span><br><span class="line">        <span class="keyword">if</span>(!root-&gt;left &amp;&amp; !root-&gt;right) &#123;</span><br><span class="line">            <span class="keyword">if</span>(!cur) res.<span class="built_in">push_back</span>(path);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left) <span class="built_in">dfs</span>(root-&gt;left, cur);</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;right) <span class="built_in">dfs</span>(root-&gt;right, cur);</span><br><span class="line">        path.<span class="built_in">pop_back</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="剑指-Offer-35-复杂链表的复制"><a href="#剑指-Offer-35-复杂链表的复制" class="headerlink" title="剑指 Offer 35. 复杂链表的复制"></a><a href="https://leetcode.cn/problems/fu-za-lian-biao-de-fu-zhi-lcof/">剑指 Offer 35. 复杂链表的复制</a></h4><p>常规方法：通过哈希表快速获取random指向的节点</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    unordered_map&lt;Node*, Node*&gt; mp;</span><br><span class="line"></span><br><span class="line">    <span class="function">Node* <span class="title">copyRandomList</span><span class="params">(Node* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!head) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">if</span>(!mp.<span class="built_in">count</span>(head)) &#123;    <span class="comment">//第一次复制该节点</span></span><br><span class="line">            <span class="keyword">auto</span> node = <span class="keyword">new</span> <span class="built_in">Node</span>(head-&gt;val);</span><br><span class="line">            mp[head] = node;</span><br><span class="line">            node-&gt;next = <span class="built_in">copyRandomList</span>(head-&gt;next);</span><br><span class="line">            node-&gt;random = <span class="built_in">copyRandomList</span>(head-&gt;random);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> mp[head];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>常数空间复杂度方法: 三步法</p><ol><li>复制一份 1-&gt;2-&gt;3-&gt;4  编程1-&gt;1-&gt;2-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4</li><li>为复制出来的一份添加random指针</li><li>按奇偶分割成两个链表</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Node* <span class="title">copyRandomList</span><span class="params">(Node* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!head) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> p = head; p; p = p-&gt;next-&gt;next) &#123;</span><br><span class="line">            <span class="keyword">auto</span> node = <span class="keyword">new</span> <span class="built_in">Node</span>(p-&gt;val);</span><br><span class="line">            node-&gt;next = p-&gt;next;</span><br><span class="line">            p-&gt;next = node;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> p = head; p; p = p-&gt;next-&gt;next) &#123;</span><br><span class="line">            <span class="keyword">auto</span> newNode = p-&gt;next;</span><br><span class="line">            newNode-&gt;random = p-&gt;random ? p-&gt;random-&gt;next : <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">auto</span> newHead = head-&gt;next;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> p = head; p; p = p-&gt;next) &#123;</span><br><span class="line">            <span class="keyword">auto</span> newNode = p-&gt;next;</span><br><span class="line">            p-&gt;next = newNode-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(p-&gt;next) newNode-&gt;next = p-&gt;next-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> newHead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="426-将二叉搜索树转化为排序的双向链表"><a href="#426-将二叉搜索树转化为排序的双向链表" class="headerlink" title="426. 将二叉搜索树转化为排序的双向链表"></a><a href="https://leetcode.cn/problems/convert-binary-search-tree-to-sorted-doubly-linked-list/">426. 将二叉搜索树转化为排序的双向链表</a></h4><p>中序遍历</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Node *head = <span class="literal">NULL</span>, *pre = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="function">Node* <span class="title">treeToDoublyList</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(root);</span><br><span class="line">        head-&gt;left = pre;</span><br><span class="line">        pre-&gt;right = head;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(root-&gt;left);</span><br><span class="line">        <span class="keyword">if</span>(!pre) &#123;</span><br><span class="line">            head = root;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            pre-&gt;right = root;</span><br><span class="line">            root-&gt;left = pre;</span><br><span class="line">        &#125;</span><br><span class="line">        pre = root;</span><br><span class="line">        <span class="built_in">dfs</span>(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="剑指-Offer-37-序列化二叉树"><a href="#剑指-Offer-37-序列化二叉树" class="headerlink" title="*剑指 Offer 37. 序列化二叉树"></a><a href="https://leetcode.cn/problems/xu-lie-hua-er-cha-shu-lcof/">*剑指 Offer 37. 序列化二叉树</a></h4><p>按前序编码</p><p>每个元素用逗号分割， 空指针用’#’表示</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Codec</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    string s; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// Encodes a tree to a single string.</span></span><br><span class="line">    <span class="function">string <span class="title">serialize</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        s.<span class="built_in">clear</span>();</span><br><span class="line">        <span class="built_in">dfs1</span>(root);</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Decodes your encoded data to tree.</span></span><br><span class="line">    <span class="function">TreeNode* <span class="title">deserialize</span><span class="params">(string data)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> u = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dfs2</span>(data, u);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs1</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) &#123;</span><br><span class="line">            s += <span class="string">&quot;#,&quot;</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        s += <span class="built_in">to_string</span>(root-&gt;val) + <span class="string">&quot;,&quot;</span>;</span><br><span class="line">        <span class="built_in">dfs1</span>(root-&gt;left);</span><br><span class="line">        <span class="built_in">dfs1</span>(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode* <span class="title">dfs2</span><span class="params">(string&amp; data, <span class="type">int</span>&amp; u)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(data[u] == <span class="string">&#x27;#&#x27;</span>) &#123;</span><br><span class="line">            u += <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> k = u;</span><br><span class="line">        <span class="keyword">while</span>(data[u] != <span class="string">&#x27;,&#x27;</span>) u++;</span><br><span class="line">        <span class="keyword">auto</span> root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(<span class="built_in">stoi</span>(data.<span class="built_in">substr</span>(k, u-k)));</span><br><span class="line">        u++;</span><br><span class="line">        root-&gt;left = <span class="built_in">dfs2</span>(data, u);</span><br><span class="line">        root-&gt;right = <span class="built_in">dfs2</span>(data, u);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="剑指-Offer-38-字符串的排列"><a href="#剑指-Offer-38-字符串的排列" class="headerlink" title="*剑指 Offer 38. 字符串的排列"></a><a href="https://leetcode.cn/problems/zi-fu-chuan-de-pai-lie-lcof/">*剑指 Offer 38. 字符串的排列</a></h4><p>回溯</p><p>为每一个位置挑选所有可能的字符</p><p>精髓： 为避免重复， 可以先将字符串排序， 对于相同的字符，只有靠前的已经被选择，才可以选择靠后的</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;string&gt; res;</span><br><span class="line">    string path;</span><br><span class="line">    vector&lt;<span class="type">bool</span>&gt; st;</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">permutation</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>(s.<span class="built_in">begin</span>(), s.<span class="built_in">end</span>());</span><br><span class="line">        st.<span class="built_in">resize</span>(s.<span class="built_in">size</span>());</span><br><span class="line">        <span class="built_in">dfs</span>(s, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(string &amp;s, <span class="type">int</span> u)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(u == s.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(path);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(st[i] || (i &amp;&amp; s[i<span class="number">-1</span>] == s[i] &amp;&amp; !st[i<span class="number">-1</span>])) <span class="keyword">continue</span>; <span class="comment">// 避免重复</span></span><br><span class="line">            path += s[i];</span><br><span class="line">            st[i] = <span class="literal">true</span>;</span><br><span class="line">            <span class="built_in">dfs</span>(s, u+<span class="number">1</span>);</span><br><span class="line">            st[i] = <span class="literal">false</span>;</span><br><span class="line">            path.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="剑指-Offer-39-数组中出现次数超过一半的数字"><a href="#剑指-Offer-39-数组中出现次数超过一半的数字" class="headerlink" title="剑指 Offer 39. 数组中出现次数超过一半的数字"></a><a href="https://leetcode.cn/problems/shu-zu-zhong-chu-xian-ci-shu-chao-guo-yi-ban-de-shu-zi-lcof/">剑指 Offer 39. 数组中出现次数超过一半的数字</a></h4><p>目标数字减所有其余数字肯定大于0</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">majorityElement</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> cnt = <span class="number">0</span>, res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> x: nums) &#123;</span><br><span class="line">            <span class="keyword">if</span>(cnt == <span class="number">0</span>) &#123;</span><br><span class="line">                res = x;</span><br><span class="line">                cnt++;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">if</span>(x == res) cnt++;</span><br><span class="line">            <span class="keyword">else</span> cnt--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="剑指-Offer-40-最小的k个数"><a href="#剑指-Offer-40-最小的k个数" class="headerlink" title="*剑指 Offer 40. 最小的k个数"></a><a href="https://leetcode.cn/problems/zui-xiao-de-kge-shu-lcof/">*剑指 Offer 40. 最小的k个数</a></h4><p>堆， 时间O(nlogk)， 空间O(k)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">getLeastNumbers</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!k) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        priority_queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; k; i++) q.<span class="built_in">push</span>(arr[i]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = k; i &lt; arr.<span class="built_in">size</span>(); i++) </span><br><span class="line">            <span class="keyword">if</span>(arr[i] &lt; q.<span class="built_in">top</span>()) q.<span class="built_in">pop</span>(), q.<span class="built_in">push</span>(arr[i]);</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">while</span>(q.<span class="built_in">size</span>()) res.<span class="built_in">push_back</span>(q.<span class="built_in">top</span>()), q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>快速选择，时间 O(n)，空间O(logn)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">getLeastNumbers</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">qSlect</span>(arr, <span class="number">0</span>, arr.<span class="built_in">size</span>()<span class="number">-1</span>, k);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(arr.<span class="built_in">begin</span>(),arr.<span class="built_in">begin</span>()+k);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">qSlect</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l &gt;= r) <span class="keyword">return</span>;</span><br><span class="line">        <span class="type">int</span> i = l<span class="number">-1</span>, j = r+<span class="number">1</span>, x = nums[l + r &gt;&gt; <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">while</span>(i &lt; j) &#123;</span><br><span class="line">            <span class="keyword">while</span>(nums[++i] &lt; x);</span><br><span class="line">            <span class="keyword">while</span>(nums[--j] &gt; x);</span><br><span class="line">            <span class="keyword">if</span>(i &lt; j) <span class="built_in">swap</span>(nums[i], nums[j]);</span><br><span class="line">        &#125;   </span><br><span class="line">        <span class="type">int</span> cnt = j - l + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(cnt &gt;= k) <span class="built_in">qSlect</span>(nums, l, j, k);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">qSlect</span>(nums, j+<span class="number">1</span>, r, k-cnt);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>计数排序，时间 O(m)，空间O(m)，m为数据范围</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">getLeastNumbers</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = arr.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">f</span><span class="params">(<span class="number">10001</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> x: arr) f[x]++;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">10000</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(!k) <span class="keyword">break</span>;</span><br><span class="line">            <span class="type">int</span> cnt = <span class="built_in">min</span>(f[i], k);</span><br><span class="line">            k -= cnt;</span><br><span class="line">            <span class="keyword">while</span>(cnt--) res.<span class="built_in">push_back</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="困难-剑指-Offer-41-数据流中的中位数"><a href="#困难-剑指-Offer-41-数据流中的中位数" class="headerlink" title="*(困难)剑指 Offer 41. 数据流中的中位数"></a><a href="https://leetcode.cn/problems/shu-ju-liu-zhong-de-zhong-wei-shu-lcof/">*(困难)剑指 Offer 41. 数据流中的中位数</a></h4><p>双堆</p><p>首先保证大根堆中的元素小于等于小根堆中的元素，再考虑数量</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MedianFinder</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    priority_queue&lt;<span class="type">int</span>&gt; big;    <span class="comment">// 较小一半数</span></span><br><span class="line">    priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, greater&lt;<span class="type">int</span>&gt;&gt; small; <span class="comment">// 较大一般数</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">MedianFinder</span>() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 规定big.size() &gt;= small.size()</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addNum</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(big.<span class="built_in">empty</span>() || num &lt;= big.<span class="built_in">top</span>()) &#123;    <span class="comment">// 首先保证big中的元素小于等于small中的元素，再考虑数量</span></span><br><span class="line">            big.<span class="built_in">push</span>(num);</span><br><span class="line">            <span class="keyword">if</span>(big.<span class="built_in">size</span>() &gt; small.<span class="built_in">size</span>() + <span class="number">1</span>) &#123;</span><br><span class="line">                small.<span class="built_in">push</span>(big.<span class="built_in">top</span>());</span><br><span class="line">                big.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            small.<span class="built_in">push</span>(num);</span><br><span class="line">            <span class="keyword">if</span>(small.<span class="built_in">size</span>() &gt; big.<span class="built_in">size</span>()) &#123;</span><br><span class="line">                big.<span class="built_in">push</span>(small.<span class="built_in">top</span>());</span><br><span class="line">                small.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">findMedian</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(big.<span class="built_in">size</span>() == small.<span class="built_in">size</span>()) <span class="keyword">return</span> (big.<span class="built_in">top</span>() + small.<span class="built_in">top</span>()) / <span class="number">2.0</span>;</span><br><span class="line">        <span class="keyword">return</span> big.<span class="built_in">top</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="剑指-Offer-42-连续子数组的最大和"><a href="#剑指-Offer-42-连续子数组的最大和" class="headerlink" title="剑指 Offer 42. 连续子数组的最大和"></a><a href="https://leetcode.cn/problems/lian-xu-zi-shu-zu-de-zui-da-he-lcof/">剑指 Offer 42. 连续子数组的最大和</a></h4><p>每一步都更新一次答案</p><p>sum &lt; 0时抛弃前面的数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxSubArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = INT_MIN, sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> x: nums) &#123;</span><br><span class="line">            sum = <span class="built_in">max</span>(sum, <span class="number">0</span>);</span><br><span class="line">            sum += x;</span><br><span class="line">            res = <span class="built_in">max</span>(res, sum);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="剑指-Offer-43-1～n-整数中-1-出现的次数"><a href="#剑指-Offer-43-1～n-整数中-1-出现的次数" class="headerlink" title="*剑指 Offer 43. 1～n 整数中 1 出现的次数"></a><a href="https://leetcode.cn/problems/1nzheng-shu-zhong-1chu-xian-de-ci-shu-lcof/">*剑指 Offer 43. 1～n 整数中 1 出现的次数</a></h4><p>统计每一位上1出现的次数</p><p>分类讨论<code>1234x678</code></p><p>当<code>x==0</code>时, 左边四位取0<del>1233， x取1，右边四位取0</del>999</p><p>当<code>x==1</code>时，左边四位取0<del>1233， x取1，右边四位取0</del>999；或者左边取1234，x取1，右边取0~678</p><p>当<code>x&gt;1</code>时， 左边取0<del>1234，x取1，右边取0</del>999；</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">countDigitOne</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">long</span> <span class="type">long</span> <span class="type">int</span> i = <span class="number">1</span>; n/i; i *= <span class="number">10</span>) &#123;</span><br><span class="line">            <span class="type">int</span> left = n / (i*<span class="number">10</span>);</span><br><span class="line">            <span class="type">int</span> cur = n/i % <span class="number">10</span>;</span><br><span class="line">            <span class="type">int</span> right = n - n/i*i;</span><br><span class="line">            <span class="keyword">if</span>(cur == <span class="number">0</span>) res += left * i;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(cur == <span class="number">1</span>) res += left * i + right + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> res += (left + <span class="number">1</span>) * i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="剑指-Offer-44-数字序列中某一位的数字"><a href="#剑指-Offer-44-数字序列中某一位的数字" class="headerlink" title="*剑指 Offer 44. 数字序列中某一位的数字"></a><a href="https://leetcode.cn/problems/shu-zi-xu-lie-zhong-mou-yi-wei-de-shu-zi-lcof/">*剑指 Offer 44. 数字序列中某一位的数字</a></h4><p>先确定是几位数中的数字， 然后确定是第几个x位数， 然后确定是这个x位数的第几个数字</p><p>题目是从数字0开始，第i位（从0计数）， 可以转化为从1开始，第i位(从1计数)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findNthDigit</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> k = <span class="number">1</span>, t = <span class="number">9</span>, start = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(n &gt; k*t) &#123;</span><br><span class="line">            n -= k*t;</span><br><span class="line">            k++;</span><br><span class="line">            t *= <span class="number">10</span>;</span><br><span class="line">            start *= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        start += (n + k - <span class="number">1</span>) / k <span class="number">-1</span>; <span class="comment">// 向上取整</span></span><br><span class="line">        n = n%k ? n%k : k;    <span class="comment">// n=0应该是start最后一位</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">to_string</span>(start)[n<span class="number">-1</span>] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="剑指-Offer-45-把数组排成最小的数"><a href="#剑指-Offer-45-把数组排成最小的数" class="headerlink" title="剑指 Offer 45. 把数组排成最小的数"></a><a href="https://leetcode.cn/problems/ba-shu-zu-pai-cheng-zui-xiao-de-shu-lcof/">剑指 Offer 45. 把数组排成最小的数</a></h4><p>按照规则排序： 将数字u，v转换成字符串<code>su</code>，<code>sv</code>，若<code>su+sv &lt; sv+su</code>，则u排在前边，否则v排在前边</p><p>转化成字符串可以防止爆int</p><p>可以用反证法证明：假设最优解中存在a在b前，且a&gt;b,替换ab可以得到更小的数，矛盾。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">minNumber</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), [](<span class="keyword">auto</span>&amp; u, <span class="keyword">auto</span>&amp;v) &#123;</span><br><span class="line">            string su = <span class="built_in">to_string</span>(u), sv = <span class="built_in">to_string</span>(v);</span><br><span class="line">            <span class="keyword">return</span> su+sv &lt; sv+su;</span><br><span class="line">        &#125;);</span><br><span class="line">        string res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> x: nums) res += <span class="built_in">to_string</span>(x);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>快排版本</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">minNumber</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;string&gt; <span class="title">strs</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) strs[i] = <span class="built_in">to_string</span>(nums[i]);</span><br><span class="line">        <span class="built_in">qSort</span>(strs, <span class="number">0</span>, n<span class="number">-1</span>);</span><br><span class="line">        string res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> s: strs) res += s;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">qSort</span><span class="params">(vector&lt;string&gt;&amp; nums, <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l &gt;= r) <span class="keyword">return</span>;</span><br><span class="line">        <span class="type">int</span> i = l<span class="number">-1</span>, j = r+<span class="number">1</span>;</span><br><span class="line">        string x = nums[l];</span><br><span class="line">        <span class="keyword">while</span>(i &lt; j) &#123;</span><br><span class="line">            <span class="keyword">while</span>(<span class="built_in">small</span>(nums[++i], x));</span><br><span class="line">            <span class="keyword">while</span>(<span class="built_in">big</span>(nums[--j], x));</span><br><span class="line">            <span class="keyword">if</span>(i &lt; j) <span class="built_in">swap</span>(nums[i], nums[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">qSort</span>(nums, l, j);</span><br><span class="line">        <span class="built_in">qSort</span>(nums, j+<span class="number">1</span>, r);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">small</span><span class="params">(string a, string b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a + b &lt; b + a;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">big</span><span class="params">(string a, string b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a + b &gt; b + a;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="剑指-Offer-46-把数字翻译成字符串"><a href="#剑指-Offer-46-把数字翻译成字符串" class="headerlink" title="剑指 Offer 46. 把数字翻译成字符串"></a><a href="https://leetcode.cn/problems/ba-shu-zi-fan-yi-cheng-zi-fu-chuan-lcof/">剑指 Offer 46. 把数字翻译成字符串</a></h4><p>dp避免重复计算， 从后往前算</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">translateNum</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">        string s = <span class="built_in">to_string</span>(num);</span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">f</span><span class="params">(n+<span class="number">1</span>)</span></span>;</span><br><span class="line">        f[n] = f[n<span class="number">-1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = n<span class="number">-2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            f[i] = f[i+<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span>(s[i] != <span class="string">&#x27;0&#x27;</span> &amp;&amp; <span class="built_in">stoi</span>(s.<span class="built_in">substr</span>(i, <span class="number">2</span>)) &lt; <span class="number">26</span>) f[i] += f[i+<span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>状态转移只依赖f[i+1]和f[i+2]，可以优化空间</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">translateNum</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">        string s = <span class="built_in">to_string</span>(num);</span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> a, b, c;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">f</span><span class="params">(n+<span class="number">1</span>)</span></span>;</span><br><span class="line">        b = c = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = n<span class="number">-2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            a = b;</span><br><span class="line">            <span class="keyword">if</span>(s[i] != <span class="string">&#x27;0&#x27;</span> &amp;&amp; <span class="built_in">stoi</span>(s.<span class="built_in">substr</span>(i, <span class="number">2</span>)) &lt; <span class="number">26</span>) a += c;</span><br><span class="line">            c = b, b = a;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="剑指-Offer-47-礼物的最大价值"><a href="#剑指-Offer-47-礼物的最大价值" class="headerlink" title="剑指 Offer 47. 礼物的最大价值 "></a><a href="https://leetcode.cn/problems/li-wu-de-zui-da-jie-zhi-lcof/">剑指 Offer 47. 礼物的最大价值 </a></h4><p>dp， 可以对空间进行优化， 当前状态只依赖<code>f[i-1][j]</code>和<code>f[i][j-1]</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxValue</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> m = grid.<span class="built_in">size</span>(), n = grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">f</span><span class="params">(n+<span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">                f[j] = <span class="built_in">max</span>(f[j], f[j<span class="number">-1</span>]) + grid[i<span class="number">-1</span>][j<span class="number">-1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="剑指-Offer-48-最长不含重复字符的子字符串"><a href="#剑指-Offer-48-最长不含重复字符的子字符串" class="headerlink" title="剑指 Offer 48. 最长不含重复字符的子字符串"></a><a href="https://leetcode.cn/problems/zui-chang-bu-han-zhong-fu-zi-fu-de-zi-zi-fu-chuan-lcof/">剑指 Offer 48. 最长不含重复字符的子字符串</a></h4><p>贪心+双指针</p><p>枚举了以每个字符结尾的最长不重复子串</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>, n = s.<span class="built_in">size</span>();</span><br><span class="line">        unordered_map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; mp;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            mp[s[i]]++;</span><br><span class="line">            <span class="keyword">while</span>(mp[s[i]] &gt; <span class="number">1</span>) mp[s[j++]]--;</span><br><span class="line">            res = <span class="built_in">max</span>(res, i-j+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="剑指-Offer-49-丑数"><a href="#剑指-Offer-49-丑数" class="headerlink" title="*剑指 Offer 49. 丑数"></a><a href="https://leetcode.cn/problems/chou-shu-lcof/">*剑指 Offer 49. 丑数</a></h4><p>三指针，三路归并</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">nthUglyNumber</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(<span class="number">1</span>,<span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>, k = <span class="number">0</span>; a.<span class="built_in">size</span>() &lt; n; ) &#123;</span><br><span class="line">            <span class="type">int</span> t = <span class="built_in">min</span>(<span class="built_in">min</span>(a[i]*<span class="number">2</span>, a[j]*<span class="number">3</span>), a[k]*<span class="number">5</span>);</span><br><span class="line">            a.<span class="built_in">push_back</span>(t);</span><br><span class="line">            <span class="keyword">if</span>(t == a[i]*<span class="number">2</span>) i++;</span><br><span class="line">            <span class="keyword">if</span>(t == a[j]*<span class="number">3</span>) j++;</span><br><span class="line">            <span class="keyword">if</span>(t == a[k]*<span class="number">5</span>) k++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a[n<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="剑指-Offer-50-第一个只出现一次的字符"><a href="#剑指-Offer-50-第一个只出现一次的字符" class="headerlink" title="剑指 Offer 50. 第一个只出现一次的字符"></a><a href="https://leetcode.cn/problems/di-yi-ge-zhi-chu-xian-yi-ci-de-zi-fu-lcof/">剑指 Offer 50. 第一个只出现一次的字符</a></h4><p>两次遍历字符串， 哈希表计数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">char</span> <span class="title">firstUniqChar</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; mp;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> c: s) mp[c]++;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> c: s)</span><br><span class="line">            <span class="keyword">if</span>(mp[c] == <span class="number">1</span>) <span class="keyword">return</span> c;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>第一次遍历字符串， 第二次遍历哈希表</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">char</span> <span class="title">firstUniqChar</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; mp;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="type">char</span> c = s[i];</span><br><span class="line">            <span class="keyword">if</span>(mp.<span class="built_in">count</span>(c)) mp[c] = <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">else</span> mp[c] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> p = INT_MAX;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp;[k, v]: mp) &#123;</span><br><span class="line">            <span class="keyword">if</span>(v != <span class="number">-1</span> &amp;&amp; v &lt; p) &#123;</span><br><span class="line">                p = v;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p == INT_MAX ? <span class="string">&#x27; &#x27;</span> : s[p];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="剑指-Offer-51-数组中的逆序对"><a href="#剑指-Offer-51-数组中的逆序对" class="headerlink" title="*剑指 Offer 51. 数组中的逆序对"></a><a href="https://leetcode.cn/problems/shu-zu-zhong-de-ni-xu-dui-lcof/">*剑指 Offer 51. 数组中的逆序对</a></h4><p>归并排序过程中计数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">reversePairs</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">merge</span>(nums, <span class="number">0</span>, nums.<span class="built_in">size</span>()<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">merge</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l &gt;= r) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> res = <span class="built_in">merge</span>(nums, l, mid) + <span class="built_in">merge</span>(nums, mid+<span class="number">1</span>, r);</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">t</span><span class="params">(r-l+<span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="type">int</span> i = l, j = mid+<span class="number">1</span>, k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt;= mid &amp;&amp; j &lt;= r) &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &lt;= nums[j]) t[k++] = nums[i++];</span><br><span class="line">            <span class="keyword">else</span> res += mid-i+<span class="number">1</span>, t[k++] = nums[j++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(i &lt;= mid) t[k++] = nums[i++];</span><br><span class="line">        <span class="keyword">while</span>(j &lt;= r) t[k++] = nums[j++];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> u = <span class="number">0</span>; u &lt; k; u++) nums[l+u] = t[u];</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>类似题目<a href="https://leetcode.cn/problems/reverse-pairs/">493. 翻转对</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; w;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">reversePairs</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">mergeSort</span>(nums, <span class="number">0</span>, nums.<span class="built_in">size</span>()<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">mergeSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l &gt;= r) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> res = <span class="built_in">mergeSort</span>(nums, l, mid) + <span class="built_in">mergeSort</span>(nums, mid+<span class="number">1</span>, r);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 先统计答案，再排序</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = l, j = mid+<span class="number">1</span>; i &lt;= mid; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span>(j &lt;= r &amp;&amp; nums[i] &gt; nums[j] * <span class="number">2ll</span>) j++;</span><br><span class="line">            res += j - (mid+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 归并</span></span><br><span class="line">        w.<span class="built_in">clear</span>();</span><br><span class="line">        <span class="type">int</span> i = l, j = mid+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt;= mid &amp;&amp; j &lt;= r) &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &lt;= nums[j]) w.<span class="built_in">push_back</span>(nums[i++]);</span><br><span class="line">            <span class="keyword">else</span> w.<span class="built_in">push_back</span>(nums[j++]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(i &lt;= mid) w.<span class="built_in">push_back</span>(nums[i++]);</span><br><span class="line">        <span class="keyword">while</span>(j &lt;= r) w.<span class="built_in">push_back</span>(nums[j++]);</span><br><span class="line">        <span class="keyword">for</span>(i = l, j = <span class="number">0</span>; j &lt; w.<span class="built_in">size</span>(); i++, j++) nums[i] = w[j];</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="剑指-Offer-52-两个链表的第一个公共节点"><a href="#剑指-Offer-52-两个链表的第一个公共节点" class="headerlink" title="剑指 Offer 52. 两个链表的第一个公共节点"></a><a href="https://leetcode.cn/problems/liang-ge-lian-biao-de-di-yi-ge-gong-gong-jie-dian-lcof/">剑指 Offer 52. 两个链表的第一个公共节点</a></h4><p>从公共节点之后，链表相同， 所以两个链表按结尾对齐，有相同部分。</p><p>链表A、B， p遍历AB,q遍历BA， 因为AB长度等于BA， 所以会同时遍历到A和B的结尾。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">getIntersectionNode</span><span class="params">(ListNode *headA, ListNode *headB)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!headA || !headB) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">auto</span> p = headA, q = headB;</span><br><span class="line">        <span class="keyword">while</span>(p != q) &#123;</span><br><span class="line">            p = p ? p-&gt;next : headB;</span><br><span class="line">            q = q? q-&gt;next : headA;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p ? p : <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="剑指-Offer-53-I-在排序数组中查找数字-I"><a href="#剑指-Offer-53-I-在排序数组中查找数字-I" class="headerlink" title="剑指 Offer 53 - I. 在排序数组中查找数字 I"></a><a href="https://leetcode.cn/problems/zai-pai-xu-shu-zu-zhong-cha-zhao-shu-zi-lcof/">剑指 Offer 53 - I. 在排序数组中查找数字 I</a></h4><p>两次二分，查找元素的第一个和最后一个位置</p><p>注意数组判空和数组中是否有该元素</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">search</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(!n) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> l = <span class="number">0</span>, r = n<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l &lt; r) &#123;</span><br><span class="line">            <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &gt;= target) r = mid;</span><br><span class="line">            <span class="keyword">else</span> l = mid+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(nums[l] != target) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> t = l;</span><br><span class="line">        r = n<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l &lt; r) &#123;</span><br><span class="line">            <span class="type">int</span> mid = l + r + <span class="number">1</span> &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &lt;= target) l = mid;</span><br><span class="line">            <span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> l - t + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="剑指-Offer-53-II-0～n-1中缺失的数字"><a href="#剑指-Offer-53-II-0～n-1中缺失的数字" class="headerlink" title="剑指 Offer 53 - II. 0～n-1中缺失的数字"></a><a href="https://leetcode.cn/problems/que-shi-de-shu-zi-lcof/">剑指 Offer 53 - II. 0～n-1中缺失的数字</a></h4><p>法一： n*(n+1)&#x2F;2 - sum， O(n)没有利用条件：有序</p><p>法二： 二分， 找第一个数字大于下标的位置。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">missingNumber</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> l = <span class="number">0</span>, r = nums.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l &lt; r) &#123;</span><br><span class="line">            <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &gt; mid) r = mid;</span><br><span class="line">            <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[l] != l ? l : l+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="剑指-Offer-54-二叉搜索树的第k大节点"><a href="#剑指-Offer-54-二叉搜索树的第k大节点" class="headerlink" title="剑指 Offer 54. 二叉搜索树的第k大节点"></a><a href="https://leetcode.cn/problems/er-cha-sou-suo-shu-de-di-kda-jie-dian-lcof/">剑指 Offer 54. 二叉搜索树的第k大节点</a></h4><p>二叉搜索树性质， 中序遍历倒序 + 计数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> res;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">kthLargest</span><span class="params">(TreeNode* root, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">dfs</span>(root, k);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(TreeNode* root, <span class="type">int</span>&amp; k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(root-&gt;right, k);</span><br><span class="line">        k--;</span><br><span class="line">        <span class="keyword">if</span>(!k) &#123;</span><br><span class="line">            res = root-&gt;val;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">dfs</span>(root-&gt;left, k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="剑指-Offer-55-I-二叉树的深度"><a href="#剑指-Offer-55-I-二叉树的深度" class="headerlink" title="剑指 Offer 55 - I. 二叉树的深度"></a><a href="https://leetcode.cn/problems/er-cha-shu-de-shen-du-lcof/">剑指 Offer 55 - I. 二叉树的深度</a></h4><p>递归</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + <span class="built_in">max</span>(<span class="built_in">maxDepth</span>(root-&gt;left), <span class="built_in">maxDepth</span>(root-&gt;right));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="剑指-Offer-55-II-平衡二叉树"><a href="#剑指-Offer-55-II-平衡二叉树" class="headerlink" title="剑指 Offer 55 - II. 平衡二叉树"></a><a href="https://leetcode.cn/problems/ping-heng-er-cha-shu-lcof/">剑指 Offer 55 - II. 平衡二叉树</a></h4><p>两次遍历</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isBalanced</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> root == <span class="literal">nullptr</span> ? <span class="literal">true</span> : <span class="built_in">isBalanced</span>(root-&gt;left) &amp;&amp; <span class="built_in">isBalanced</span>(root-&gt;right) &amp;&amp; <span class="built_in">abs</span>(<span class="built_in">depth</span>(root-&gt;left) - <span class="built_in">depth</span>(root-&gt;right)) &lt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">depth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> root == <span class="literal">nullptr</span> ? <span class="number">0</span> : <span class="built_in">max</span>(<span class="built_in">depth</span>(root-&gt;left), <span class="built_in">depth</span>(root-&gt;right)) + <span class="number">1</span>; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>一次遍历</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isBalanced</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> depth = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">check</span>(root, depth);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(TreeNode* root, <span class="type">int</span> &amp;depth)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="type">int</span> l = <span class="number">0</span>, r = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">check</span>(root-&gt;left, l) || !<span class="built_in">check</span>(root-&gt;right, r)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        depth = <span class="built_in">max</span>(l, r) + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">abs</span>(l - r) &lt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="剑指-Offer-56-I-数组中数字出现的次数"><a href="#剑指-Offer-56-I-数组中数字出现的次数" class="headerlink" title="剑指 Offer 56 - I. 数组中数字出现的次数"></a><a href="https://leetcode.cn/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-lcof/">剑指 Offer 56 - I. 数组中数字出现的次数</a></h4><p>想办法把数组分为两部分，每部分的特点是1个数字出现一次，其余数字出现两次</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">singleNumbers</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> s = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> x: nums) s ^= x;</span><br><span class="line">        <span class="type">int</span> k = <span class="built_in">log2</span>(s &amp; -s);    <span class="comment">//记答案为a，b。找出a和b不一样的一位（异或为1的位）</span></span><br><span class="line">        <span class="type">int</span> a = <span class="number">0</span>, b = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> x: nums) &#123;</span><br><span class="line">            <span class="keyword">if</span>(x &gt;&gt; k &amp; <span class="number">1</span>) a ^= x;</span><br><span class="line">            <span class="keyword">else</span> b ^= x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;a, b&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="剑指-Offer-56-II-数组中数字出现的次数-II"><a href="#剑指-Offer-56-II-数组中数字出现的次数-II" class="headerlink" title="*剑指 Offer 56 - II. 数组中数字出现的次数 II"></a><a href="https://leetcode.cn/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-ii-lcof/">*剑指 Offer 56 - II. 数组中数字出现的次数 II</a></h4><p>依次确定每一个二进制位，对每一位求和，能被3整除说明答案的这一位为0，否则为1</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">singleNumber</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++) &#123;</span><br><span class="line">            <span class="type">int</span> k = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> x: nums) </span><br><span class="line">                <span class="keyword">if</span>(x &gt;&gt; i &amp; <span class="number">1</span>) k++; </span><br><span class="line">            <span class="keyword">if</span>(k%<span class="number">3</span>)</span><br><span class="line">                res |= <span class="number">1</span>&lt;&lt;i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="剑指-Offer-57-和为s的两个数字"><a href="#剑指-Offer-57-和为s的两个数字" class="headerlink" title="剑指 Offer 57. 和为s的两个数字"></a><a href="https://leetcode.cn/problems/he-wei-sde-liang-ge-shu-zi-lcof/">剑指 Offer 57. 和为s的两个数字</a></h4><p>数组有序，可以双指针</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>, j = nums.<span class="built_in">size</span>()<span class="number">-1</span>; i &lt; j; ) &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] + nums[j] == target) <span class="keyword">return</span> &#123;nums[i], nums[j]&#125;;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] + nums[j] &lt; target) i++;</span><br><span class="line">            <span class="keyword">else</span> j--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="剑指-Offer-57-II-和为s的连续正数序列"><a href="#剑指-Offer-57-II-和为s的连续正数序列" class="headerlink" title="*剑指 Offer 57 - II. 和为s的连续正数序列"></a><a href="https://leetcode.cn/problems/he-wei-sde-lian-xu-zheng-shu-xu-lie-lcof/">*剑指 Offer 57 - II. 和为s的连续正数序列</a></h4><p>双指针</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">findContinuousSequence</span>(<span class="type">int</span> target) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>, j = <span class="number">2</span>; i &lt; (target+<span class="number">1</span>)/<span class="number">2</span>; ) &#123;</span><br><span class="line">            <span class="type">int</span> x = (i+j)*(j-i+<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(x &gt; target) i++;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(x &lt; target) j++;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                vector&lt;<span class="type">int</span>&gt; t;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> u = i; u &lt;= j; u++) t.<span class="built_in">push_back</span>(u);</span><br><span class="line">                res.<span class="built_in">push_back</span>(t);</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="剑指-Offer-58-I-翻转单词顺序"><a href="#剑指-Offer-58-I-翻转单词顺序" class="headerlink" title="剑指 Offer 58 - I. 翻转单词顺序"></a><a href="https://leetcode.cn/problems/fan-zhuan-dan-ci-shun-xu-lcof/">剑指 Offer 58 - I. 翻转单词顺序</a></h4><p>先将整个字符串反转， 然后再反转每个单词， 注意空格问题</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">reverseWords</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">reverse</span>(s.<span class="built_in">begin</span>(), s.<span class="built_in">end</span>());</span><br><span class="line">        <span class="type">int</span> u = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i] == <span class="string">&#x27; &#x27;</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(u) s[u++] = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">            <span class="type">int</span> j = i;</span><br><span class="line">            <span class="keyword">while</span>(j &lt; s.<span class="built_in">size</span>() &amp;&amp; s[j] != <span class="string">&#x27; &#x27;</span>) s[u++] = s[j++];</span><br><span class="line">            <span class="built_in">reverse</span>(s.<span class="built_in">begin</span>()+u-(j-i), s.<span class="built_in">begin</span>()+u);</span><br><span class="line">            i = j;</span><br><span class="line">        &#125;</span><br><span class="line">        s.<span class="built_in">erase</span>(s.<span class="built_in">begin</span>()+u, s.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="剑指-Offer-58-II-左旋转字符串"><a href="#剑指-Offer-58-II-左旋转字符串" class="headerlink" title="剑指 Offer 58 - II. 左旋转字符串"></a><a href="https://leetcode.cn/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof/">剑指 Offer 58 - II. 左旋转字符串</a></h4><p>先将整个字符串反转， 然后反转前后两部分。（先将左旋部分放到末尾， 再考虑各部分顺序问题）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">reverseLeftWords</span><span class="params">(string s, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">reverse</span>(s.<span class="built_in">begin</span>(), s.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">reverse</span>(s.<span class="built_in">begin</span>(), s.<span class="built_in">end</span>()-n);</span><br><span class="line">        <span class="built_in">reverse</span>(s.<span class="built_in">end</span>()-n, s.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="困难-剑指-Offer-59-I-滑动窗口的最大值"><a href="#困难-剑指-Offer-59-I-滑动窗口的最大值" class="headerlink" title="*(困难)剑指 Offer 59 - I. 滑动窗口的最大值"></a><a href="https://leetcode.cn/problems/hua-dong-chuang-kou-de-zui-da-zhi-lcof/">*(困难)剑指 Offer 59 - I. 滑动窗口的最大值</a></h4><p>单调队列</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">maxSlidingWindow</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        deque&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span>(q.<span class="built_in">size</span>() &amp;&amp; i-q.<span class="built_in">front</span>() &gt;= k) q.<span class="built_in">pop_front</span>(); <span class="comment">//判断队头是否滑出窗口</span></span><br><span class="line">            <span class="keyword">while</span>(q.<span class="built_in">size</span>() &amp;&amp; nums[q.<span class="built_in">back</span>()] &lt;= nums[i]) q.<span class="built_in">pop_back</span>(); <span class="comment">//维护单调</span></span><br><span class="line">            q.<span class="built_in">push_back</span>(i);</span><br><span class="line">            <span class="keyword">if</span>(i &gt;= k<span class="number">-1</span>) res.<span class="built_in">push_back</span>(nums[q.<span class="built_in">front</span>()]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="剑指-Offer-59-II-队列的最大值"><a href="#剑指-Offer-59-II-队列的最大值" class="headerlink" title="剑指 Offer 59 - II. 队列的最大值"></a><a href="https://leetcode.cn/problems/dui-lie-de-zui-da-zhi-lcof/">剑指 Offer 59 - II. 队列的最大值</a></h4><p>单调队列辅助</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MaxQueue</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q1;</span><br><span class="line">    deque&lt;<span class="type">int</span>&gt; q2;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">MaxQueue</span>() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">max_value</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(q1.<span class="built_in">empty</span>()) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> q2.<span class="built_in">front</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push_back</span><span class="params">(<span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">        q1.<span class="built_in">push</span>(value);</span><br><span class="line">        <span class="keyword">while</span>(q2.<span class="built_in">size</span>() &amp;&amp; q2.<span class="built_in">back</span>() &lt;= value) q2.<span class="built_in">pop_back</span>();</span><br><span class="line">        q2.<span class="built_in">push_back</span>(value);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">pop_front</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(q1.<span class="built_in">empty</span>()) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="type">int</span> res = q1.<span class="built_in">front</span>();</span><br><span class="line">        q1.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span>(q2.<span class="built_in">front</span>() == res) q2.<span class="built_in">pop_front</span>();</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="剑指-Offer-60-n个骰子的点数"><a href="#剑指-Offer-60-n个骰子的点数" class="headerlink" title="剑指 Offer 60. n个骰子的点数"></a><a href="https://leetcode.cn/problems/nge-tou-zi-de-dian-shu-lcof/">剑指 Offer 60. n个骰子的点数</a></h4><p>概率型dp</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">double</span>&gt; <span class="title">dicesProbability</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">double</span>&gt; <span class="title">f</span><span class="params">(<span class="number">6</span>, <span class="number">1.0</span> / <span class="number">6</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="function">vector&lt;<span class="type">double</span>&gt; <span class="title">t</span><span class="params">(i*<span class="number">6</span>-(i<span class="number">-1</span>))</span></span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; f.<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span>; k &lt; <span class="number">6</span>; k++) &#123;</span><br><span class="line">                    t[j+k] += f[j]/<span class="number">6</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            f = t;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="剑指-Offer-61-扑克牌中的顺子"><a href="#剑指-Offer-61-扑克牌中的顺子" class="headerlink" title="剑指 Offer 61. 扑克牌中的顺子"></a><a href="https://leetcode.cn/problems/bu-ke-pai-zhong-de-shun-zi-lcof/">剑指 Offer 61. 扑克牌中的顺子</a></h4><p>遇到对子返回<code>false</code></p><p>统计癞子数和空缺的数量， 最后看癞子能不能弥补空缺</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isStraight</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="type">int</span> n0 = <span class="number">0</span>, gap = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[<span class="number">0</span>] == <span class="number">0</span>) n0++;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] == <span class="number">0</span>) &#123;</span><br><span class="line">                n0++;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(nums[i<span class="number">-1</span>] == nums[i]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[i<span class="number">-1</span>] != <span class="number">0</span>) gap += nums[i] - nums[i<span class="number">-1</span>] <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> gap &lt;= n0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="剑指-Offer-62-圆圈中最后剩下的数字"><a href="#剑指-Offer-62-圆圈中最后剩下的数字" class="headerlink" title="*剑指 Offer 62. 圆圈中最后剩下的数字"></a><a href="https://leetcode.cn/problems/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-lcof/">*剑指 Offer 62. 圆圈中最后剩下的数字</a></h4><p>约瑟夫环, 递归</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lastRemaining</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> m)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> (m + <span class="built_in">lastRemaining</span>(n<span class="number">-1</span>, m)) % n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="剑指-Offer-63-股票的最大利润"><a href="#剑指-Offer-63-股票的最大利润" class="headerlink" title="剑指 Offer 63. 股票的最大利润"></a><a href="https://leetcode.cn/problems/gu-piao-de-zui-da-li-run-lcof/">剑指 Offer 63. 股票的最大利润</a></h4><p>记录之前的最小值， 计算每一天卖出的利润最大值</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> minv = INT_MAX;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> x: prices) &#123;</span><br><span class="line">            res = <span class="built_in">max</span>(res, x - minv);</span><br><span class="line">            minv = <span class="built_in">min</span>(minv, x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="剑指-Offer-64-求1-2-…-n"><a href="#剑指-Offer-64-求1-2-…-n" class="headerlink" title="剑指 Offer 64. 求1+2+…+n"></a><a href="https://leetcode.cn/problems/qiu-12n-lcof/">剑指 Offer 64. 求1+2+…+n</a></h4><p>法一：递归</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">sumNums</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        n &amp;&amp; (n += <span class="built_in">sumNums</span>(n<span class="number">-1</span>));</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>法二：计算内存</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">sumNums</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sizeof</span>(<span class="type">char</span>[n][n+<span class="number">1</span>])&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="剑指-Offer-65-不用加减乘除做加法"><a href="#剑指-Offer-65-不用加减乘除做加法" class="headerlink" title="剑指 Offer 65. 不用加减乘除做加法"></a><a href="https://leetcode.cn/problems/bu-yong-jia-jian-cheng-chu-zuo-jia-fa-lcof/">剑指 Offer 65. 不用加减乘除做加法</a></h4><p>位运算</p><ul><li>异或： 不带进位的二进制加法</li><li>与&lt;&lt;1 ：进位</li></ul><p>每次递归， b末尾必定多一个0， 所以最终b一定会等于0</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!b) <span class="keyword">return</span> a;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">add</span>(a^b, (<span class="type">unsigned</span> <span class="type">int</span>)(a&amp;b)&lt;&lt;<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="剑指-Offer-66-构建乘积数组"><a href="#剑指-Offer-66-构建乘积数组" class="headerlink" title="剑指 Offer 66. 构建乘积数组"></a><a href="https://leetcode.cn/problems/gou-jian-cheng-ji-shu-zu-lcof/">剑指 Offer 66. 构建乘积数组</a></h4><p>先左后右</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">constructArr</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; a)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = a.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(!n) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">res</span><span class="params">(n, <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>, L = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            res[i] *= L;</span><br><span class="line">            L *= a[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = n<span class="number">-1</span>, R = <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            res[i] *= R;</span><br><span class="line">            R *= a[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="剑指-Offer-67-把字符串转换成整数"><a href="#剑指-Offer-67-把字符串转换成整数" class="headerlink" title="剑指 Offer 67. 把字符串转换成整数"></a><a href="https://leetcode.cn/problems/ba-zi-fu-chuan-zhuan-huan-cheng-zheng-shu-lcof/">剑指 Offer 67. 把字符串转换成整数</a></h4><p>注意处理边界条件</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">strToInt</span><span class="params">(string str)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = str.<span class="built_in">size</span>(), i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; n &amp;&amp; str[i] == <span class="string">&#x27; &#x27;</span>) i++;</span><br><span class="line">        <span class="keyword">if</span>(i == n) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> op = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(str[i] == <span class="string">&#x27;+&#x27;</span>) i++;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(str[i] == <span class="string">&#x27;-&#x27;</span>) op = <span class="number">-1</span>, i++;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; n &amp;&amp; <span class="built_in">isdigit</span>(str[i])) &#123;</span><br><span class="line">            <span class="type">int</span> x = str[i++] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span>(res &gt; <span class="number">214748364</span> || res == <span class="number">214748364</span> &amp;&amp; x &gt;= <span class="number">8</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span>(op == <span class="number">1</span>) <span class="keyword">return</span> INT_MAX;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">return</span> INT_MIN;</span><br><span class="line">            &#125;</span><br><span class="line">            res = res*<span class="number">10</span> + x;</span><br><span class="line">        &#125; </span><br><span class="line">        </span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        *借助long long判断溢出</span></span><br><span class="line"><span class="comment">        long long res = 0;</span></span><br><span class="line"><span class="comment">        while(i &lt; n &amp;&amp; isdigit(str[i])) &#123;</span></span><br><span class="line"><span class="comment">            int x = str[i++] - &#x27;0&#x27;;</span></span><br><span class="line"><span class="comment">            res = res*10 + x;</span></span><br><span class="line"><span class="comment">            if(op == 1 &amp;&amp; res &gt;= INT_MAX) return INT_MAX;</span></span><br><span class="line"><span class="comment">            if(op == -1 &amp;&amp; -res &lt;= INT_MIN) return INT_MIN;</span></span><br><span class="line"><span class="comment">        &#125;*/</span></span><br><span class="line">        <span class="keyword">return</span> res*op;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="剑指-Offer-68-I-二叉搜索树的最近公共祖先"><a href="#剑指-Offer-68-I-二叉搜索树的最近公共祖先" class="headerlink" title="剑指 Offer 68 - I. 二叉搜索树的最近公共祖先"></a><a href="https://leetcode.cn/problems/er-cha-sou-suo-shu-de-zui-jin-gong-gong-zu-xian-lcof/">剑指 Offer 68 - I. 二叉搜索树的最近公共祖先</a></h4><p>二叉搜索树性质</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == p || root == q) <span class="keyword">return</span> root;</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;val &lt; root-&gt;val &amp;&amp; q-&gt;val &lt; root-&gt;val) <span class="keyword">return</span> <span class="built_in">lowestCommonAncestor</span>(root-&gt;left, p, q);</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;val &gt; root-&gt;val &amp;&amp; q-&gt;val &gt; root-&gt;val) <span class="keyword">return</span> <span class="built_in">lowestCommonAncestor</span>(root-&gt;right, p, q);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="剑指-Offer-68-II-二叉树的最近公共祖先"><a href="#剑指-Offer-68-II-二叉树的最近公共祖先" class="headerlink" title="剑指 Offer 68 - II. 二叉树的最近公共祖先"></a><a href="https://leetcode.cn/problems/er-cha-shu-de-zui-jin-gong-gong-zu-xian-lcof/">剑指 Offer 68 - II. 二叉树的最近公共祖先</a></h4><p>这个函数的功能有三个：给定两个节点 p 和 q</p><p>如果 p 和 q 都存在，则返回它们的公共祖先；<br>如果只存在一个，则返回存在的一个；<br>如果 p 和 q 都不存在，则返回NULL</p><p>本题说给定的两个节点都存在，那自然还是能用上面的函数来解决</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root || root == p || root == q) <span class="keyword">return</span> root;</span><br><span class="line">        <span class="keyword">auto</span> l = <span class="built_in">lowestCommonAncestor</span>(root-&gt;left, p, q);</span><br><span class="line">        <span class="keyword">auto</span> r = <span class="built_in">lowestCommonAncestor</span>(root-&gt;right, p, q);</span><br><span class="line">        <span class="keyword">if</span>(!l &amp;&amp; !r) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">if</span>(!l) <span class="keyword">return</span> r;</span><br><span class="line">        <span class="keyword">if</span>(!r) <span class="keyword">return</span> l;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;剑指-Offer-03-数组中重复的数字&quot;&gt;&lt;a href=&quot;#剑指-Offer-03-数组中重复的数字&quot; class=&quot;headerlink&quot; title=&quot;剑指 Offer 03. 数组中重复的数字&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode</summary>
      
    
    
    
    <category term="算法" scheme="https://xielingfan.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="剑指offer" scheme="https://xielingfan.github.io/tags/%E5%89%91%E6%8C%87offer/"/>
    
  </entry>
  
  <entry>
    <title>算法题总结——交换配对问题</title>
    <link href="https://xielingfan.github.io/2022/05/30/%E7%AE%97%E6%B3%95%E9%A2%98%E6%80%BB%E7%BB%93%E2%80%94%E2%80%94%E4%BA%A4%E6%8D%A2%E9%85%8D%E5%AF%B9%E9%97%AE%E9%A2%98/"/>
    <id>https://xielingfan.github.io/2022/05/30/%E7%AE%97%E6%B3%95%E9%A2%98%E6%80%BB%E7%BB%93%E2%80%94%E2%80%94%E4%BA%A4%E6%8D%A2%E9%85%8D%E5%AF%B9%E9%97%AE%E9%A2%98/</id>
    <published>2022-05-30T09:29:19.000Z</published>
    <updated>2022-05-30T14:00:03.861Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目特点"><a href="#题目特点" class="headerlink" title="题目特点"></a>题目特点</h1><ul><li>类型一： 给出一个字符串（或数组）， 交换某些元素，使得元素按照题目要求两两配对，求最小交换次数。</li><li>类型二： 给出两个字符串s1和s2， 交换s1中的元素， 使s1&#x3D;&#x3D;s2， 求最小交换次数。</li></ul><p><strong>基本思想</strong>： 将题目转化为图</p><p>举个例子，假设每个字符要与自身配对，初始配对为ab, bc, ca, dd, ef, fe。目标配对为aa, bb, cc, dd, ee, ff</p><p>a与b配对，则在ab之间添加一条有向边，下图表示初始配对和目标配对 。题目可以转化为，<strong>将图转化为全部是自环的图需要的最少交换次数</strong>。</p><p><img src="/../img/match.png" alt="match"></p><p>关键点：</p><ul><li>环内交换，1个环会变成2个环;  环间交换， 2个环会合并成1个环。</li><li>将一个连通块转化为自环图需要的交换次数： 连通块大小-1</li></ul><h1 id="例题总结"><a href="#例题总结" class="headerlink" title="例题总结"></a>例题总结</h1><h2 id="配对方式唯一"><a href="#配对方式唯一" class="headerlink" title="配对方式唯一"></a>配对方式唯一</h2><h3 id="765-情侣牵手"><a href="#765-情侣牵手" class="headerlink" title="765. 情侣牵手"></a><a href="https://leetcode.cn/problems/couples-holding-hands/">765. 情侣牵手</a></h3><p><strong>题目</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">n 对情侣坐在连续排列的 2n 个座位上，想要牵到对方的手。</span><br><span class="line"></span><br><span class="line">人和座位由一个整数数组 row 表示，其中 row[i] 是坐在第 i 个座位上的人的 ID。情侣们按顺序编号，第一对是 (0, 1)，第二对是 (2, 3)，以此类推，最后一对是 (2n-2, 2n-1)。</span><br><span class="line"></span><br><span class="line">返回 最少交换座位的次数，以便每对情侣可以并肩坐在一起。 每次交换可选择任意两人，让他们站起来交换座位。</span><br></pre></td></tr></table></figure><p><strong>思路</strong></p><p>假设共N对情侣， 形成了n个环， 每个环的大小为Ni</p><p>至少交换次数 &#x3D;  (N1 - 1) + (N2 - 1) + … + (Nn - 1) &#x3D; N - n</p><p>所以  至少交换的次数 &#x3D; 所有情侣的对数 - 并查集里连通分量的个数</p><p><strong>代码</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; p;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(p[x] != x) p[x] = <span class="built_in">find</span>(p[x]);</span><br><span class="line">        <span class="keyword">return</span> p[x];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minSwapsCouples</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; row)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = row.<span class="built_in">size</span>() / <span class="number">2</span>;</span><br><span class="line">        p.<span class="built_in">resize</span>(n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) p[i] = i;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> cnt = n;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>*n; i += <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="type">int</span> a = row[i]/<span class="number">2</span>, b = row[i+<span class="number">1</span>]/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">find</span>(a) != <span class="built_in">find</span>(b)) &#123;</span><br><span class="line">                p[<span class="built_in">find</span>(a)] = <span class="built_in">find</span>(b);</span><br><span class="line">                cnt--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n - cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="配对方式不唯一"><a href="#配对方式不唯一" class="headerlink" title="配对方式不唯一"></a>配对方式不唯一</h2><h3 id="854-相似度为-K-的字符串"><a href="#854-相似度为-K-的字符串" class="headerlink" title="854. 相似度为 K 的字符串"></a><a href="https://leetcode.cn/problems/k-similar-strings/">854. 相似度为 K 的字符串</a></h3><p><strong>题目</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">字符串 s1 和 s2 是 k 相似 的(对于某些非负整数 k )，如果我们可以交换 s1 中两个字母的位置正好 k 次，使结果字符串等于 s2 。</span><br><span class="line"></span><br><span class="line">给定两个字谜游戏 s1 和 s2 ，返回 s1 和 s2 与 k 相似 的最小 k 。</span><br><span class="line"></span><br><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入：s1 = &quot;ab&quot;, s2 = &quot;ba&quot;</span><br><span class="line">输出：1</span><br><span class="line">示例 2：</span><br><span class="line"></span><br><span class="line">输入：s1 = &quot;abc&quot;, s2 = &quot;bca&quot;</span><br><span class="line">输出：2</span><br></pre></td></tr></table></figure><p><strong>思路</strong></p><p>本题与上题的区别为： s1中的a, 可以与s2中的任意一个a配对， 即配对方式不唯一。对应到图，即环的构建方式不唯一。需要遍历每种配对方式，可以使用bfs+剪枝来做。</p><p><strong>代码</strong></p><p>bfs+剪枝</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">kSimilarity</span><span class="params">(string s1, string s2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s1 == s2) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> n = s1.<span class="built_in">size</span>();</span><br><span class="line">        queue&lt;string&gt; q;</span><br><span class="line">        unordered_map&lt;string, <span class="type">int</span>&gt; dist;</span><br><span class="line">        q.<span class="built_in">push</span>(s1);</span><br><span class="line">        dist[s1] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(q.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">auto</span> t = q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(t[i] == s2[i]) i++;    <span class="comment">// 每步只考虑第一个不匹配的元素</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = i+<span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(t[j] == s2[j] || t[j] != s2[i]) <span class="keyword">continue</span>;    <span class="comment">// t[j] == s2[j]跳过的含义： 不打乱已经匹配的元素</span></span><br><span class="line">                string next = t;</span><br><span class="line">                <span class="built_in">swap</span>(next[i], next[j]);</span><br><span class="line">                <span class="keyword">if</span>(next == s2) <span class="keyword">return</span> dist[t]+<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(dist.<span class="built_in">count</span>(next)) <span class="keyword">continue</span>;</span><br><span class="line">                q.<span class="built_in">push</span>(next);</span><br><span class="line">                dist[next] = dist[t] + <span class="number">1</span>;</span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>双向bfs</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">kSimilarity</span><span class="params">(string s1, string s2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s1 == s2) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> n = s1.<span class="built_in">size</span>();</span><br><span class="line">        queue&lt;string&gt; q1, q2;</span><br><span class="line">        unordered_map&lt;string, <span class="type">int</span>&gt; dist1, dist2;</span><br><span class="line">        q1.<span class="built_in">push</span>(s1);</span><br><span class="line">        dist1[s1] = <span class="number">0</span>;</span><br><span class="line">        q2.<span class="built_in">push</span>(s2);</span><br><span class="line">        dist2[s2] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(q1.<span class="built_in">size</span>() &amp;&amp; q2.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">if</span>(q1.<span class="built_in">size</span>() &lt; q2.<span class="built_in">size</span>()) &#123;</span><br><span class="line">                <span class="keyword">auto</span> t = q1.<span class="built_in">front</span>();</span><br><span class="line">                q1.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">while</span>(t[i] == s2[i]) i++;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j = i+<span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(t[j] == s2[j] || t[j] != s2[i]) <span class="keyword">continue</span>;</span><br><span class="line">                    string next = t;</span><br><span class="line">                    <span class="built_in">swap</span>(next[i], next[j]);</span><br><span class="line">                    <span class="keyword">if</span>(dist1.<span class="built_in">count</span>(next)) <span class="keyword">continue</span>;</span><br><span class="line">                    <span class="keyword">if</span>(dist2.<span class="built_in">count</span>(next)) <span class="keyword">return</span> dist1[t] + dist2[next] + <span class="number">1</span>;</span><br><span class="line">                    dist1[next] = dist1[t] + <span class="number">1</span>;</span><br><span class="line">                    q1.<span class="built_in">push</span>(next);</span><br><span class="line">                &#125; </span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">auto</span> t = q2.<span class="built_in">front</span>();</span><br><span class="line">                q2.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">while</span>(t[i] == s1[i]) i++;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j = i+<span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(t[j] == s1[j] || t[j] != s1[i]) <span class="keyword">continue</span>;</span><br><span class="line">                    string next = t;</span><br><span class="line">                    <span class="built_in">swap</span>(next[i], next[j]);</span><br><span class="line">                    <span class="keyword">if</span>(dist2.<span class="built_in">count</span>(next)) <span class="keyword">continue</span>;</span><br><span class="line">                    <span class="keyword">if</span>(dist1.<span class="built_in">count</span>(next)) <span class="keyword">return</span> dist2[t] + dist1[next] + <span class="number">1</span>;</span><br><span class="line">                    dist2[next] = dist2[t] + <span class="number">1</span>;</span><br><span class="line">                    q2.<span class="built_in">push</span>(next);</span><br><span class="line">                &#125; </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;题目特点&quot;&gt;&lt;a href=&quot;#题目特点&quot; class=&quot;headerlink&quot; title=&quot;题目特点&quot;&gt;&lt;/a&gt;题目特点&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;类型一： 给出一个字符串（或数组）， 交换某些元素，使得元素按照题目要求两两配对，求最小交换次数。&lt;/li&gt;
&lt;</summary>
      
    
    
    
    <category term="算法" scheme="https://xielingfan.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="并查集" scheme="https://xielingfan.github.io/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    
  </entry>
  
  <entry>
    <title>算法题总结——01bfs</title>
    <link href="https://xielingfan.github.io/2022/05/30/%E7%AE%97%E6%B3%95%E9%A2%98%E6%80%BB%E7%BB%93%E2%80%94%E2%80%9401bfs/"/>
    <id>https://xielingfan.github.io/2022/05/30/%E7%AE%97%E6%B3%95%E9%A2%98%E6%80%BB%E7%BB%93%E2%80%94%E2%80%9401bfs/</id>
    <published>2022-05-30T02:46:20.000Z</published>
    <updated>2022-05-30T08:53:08.979Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目特点"><a href="#题目特点" class="headerlink" title="题目特点"></a>题目特点</h1><p>01bfs用来解决：边权值为0或1(非0即可)，时间复杂度O( v点+e边 )。</p><p><strong>主要思想</strong>：用双端队列deque，边权值为0，push到队首，反之则到队尾。本质上是简化版的dijkstra算法， 由于边权值只有0和1，可以用双端队列代替堆维护遍历顺序。</p><h1 id="例题总结"><a href="#例题总结" class="headerlink" title="例题总结"></a>例题总结</h1><h2 id="2290-到达角落需要移除障碍物的最小数目"><a href="#2290-到达角落需要移除障碍物的最小数目" class="headerlink" title="2290. 到达角落需要移除障碍物的最小数目"></a><a href="https://leetcode.cn/problems/minimum-obstacle-removal-to-reach-corner/">2290. 到达角落需要移除障碍物的最小数目</a></h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minimumObstacles</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; g)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> m = g.<span class="built_in">size</span>(), n = g[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> dx[<span class="number">4</span>] = &#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;, dy[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>&#125;;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dist</span>(m, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n, INT_MAX));</span><br><span class="line">        dist[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        deque&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; q;</span><br><span class="line">        q.<span class="built_in">push_back</span>(&#123;<span class="number">0</span>, <span class="number">0</span>&#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(q.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">auto</span> t = q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop_front</span>();</span><br><span class="line">            <span class="type">int</span> x = t.first, y = t.second;</span><br><span class="line">            <span class="keyword">if</span>(x == m<span class="number">-1</span> &amp;&amp; y == n<span class="number">-1</span>) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">                <span class="type">int</span> a = x + dx[i], b = y + dy[i];</span><br><span class="line">                <span class="keyword">if</span>(a &gt;= <span class="number">0</span> &amp;&amp; a &lt; m &amp;&amp; b &gt;= <span class="number">0</span> &amp;&amp; b &lt; n &amp;&amp; dist[a][b] == INT_MAX) &#123;</span><br><span class="line">                    dist[a][b] = dist[x][y] + g[a][b];</span><br><span class="line">                    <span class="keyword">if</span>(g[a][b]) q.<span class="built_in">push_back</span>(&#123;a, b&#125;);</span><br><span class="line">                    <span class="keyword">else</span> q.<span class="built_in">push_front</span>(&#123;a, b&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dist[m<span class="number">-1</span>][n<span class="number">-1</span>];</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="LCP-56-信物传送"><a href="#LCP-56-信物传送" class="headerlink" title="LCP 56. 信物传送"></a><a href="https://leetcode.cn/problems/6UEx57/">LCP 56. 信物传送</a></h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">conveyorBelt</span><span class="params">(vector&lt;string&gt;&amp; matrix, vector&lt;<span class="type">int</span>&gt;&amp; start, vector&lt;<span class="type">int</span>&gt;&amp; end)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> m = matrix.<span class="built_in">size</span>(), n = matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        deque&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; q;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dist</span>(m, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n, INT_MAX));</span><br><span class="line"></span><br><span class="line">        q.<span class="built_in">push_back</span>(&#123;start[<span class="number">0</span>],start[<span class="number">1</span>]&#125;);</span><br><span class="line">        dist[start[<span class="number">0</span>]][start[<span class="number">1</span>]] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> dx[<span class="number">4</span>] = &#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;, dy[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>&#125;;</span><br><span class="line">        unordered_map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; mp&#123;</span><br><span class="line">            &#123;<span class="string">&#x27;^&#x27;</span>,<span class="number">0</span>&#125;, &#123;<span class="string">&#x27;&lt;&#x27;</span>,<span class="number">1</span>&#125;, &#123;<span class="string">&#x27;v&#x27;</span>,<span class="number">2</span>&#125;, &#123;<span class="string">&#x27;&gt;&#x27;</span>,<span class="number">3</span>&#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(q.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">auto</span> t = q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop_front</span>();</span><br><span class="line">            <span class="type">int</span> x = t.first, y = t.second;</span><br><span class="line">            <span class="keyword">if</span>(x == end[<span class="number">0</span>] &amp;&amp; y == end[<span class="number">1</span>]) <span class="keyword">return</span> dist[x][y];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">                <span class="type">int</span> a = x + dx[i], b = y + dy[i];</span><br><span class="line">                <span class="keyword">if</span>(a &lt; <span class="number">0</span> || a &gt;= m || b &lt; <span class="number">0</span> || b &gt;= n) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span>(i == mp[matrix[x][y]]) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(dist[a][b] &gt; dist[x][y]) &#123;</span><br><span class="line">                        q.<span class="built_in">push_front</span>(&#123;a, b&#125;);</span><br><span class="line">                        dist[a][b] = dist[x][y];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span>(dist[a][b] &gt; dist[x][y] + <span class="number">1</span>) &#123;</span><br><span class="line">                        q.<span class="built_in">push_back</span>(&#123;a, b&#125;);</span><br><span class="line">                        dist[a][b] = dist[x][y] + <span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="1368-使网格图至少有一条有效路径的最小代价"><a href="#1368-使网格图至少有一条有效路径的最小代价" class="headerlink" title="1368. 使网格图至少有一条有效路径的最小代价"></a><a href="https://leetcode.cn/problems/minimum-cost-to-make-at-least-one-valid-path-in-a-grid/">1368. 使网格图至少有一条有效路径的最小代价</a></h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minCost</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> m = grid.<span class="built_in">size</span>(), n = grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        deque&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; q;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dist</span>(m, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n, INT_MAX));</span><br><span class="line"></span><br><span class="line">        q.<span class="built_in">push_back</span>(&#123;<span class="number">0</span>,<span class="number">0</span>&#125;);</span><br><span class="line">        dist[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> dx[<span class="number">5</span>] = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">-1</span>&#125;, dy[<span class="number">5</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(q.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">auto</span> t = q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop_front</span>();</span><br><span class="line">            <span class="type">int</span> x = t.first, y = t.second;</span><br><span class="line">            <span class="keyword">if</span>(x == m<span class="number">-1</span> &amp;&amp; y == n<span class="number">-1</span>) <span class="keyword">return</span> dist[x][y];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">4</span>; i++) &#123;</span><br><span class="line">                <span class="type">int</span> a = x + dx[i], b = y + dy[i];</span><br><span class="line">                <span class="keyword">if</span>(a &lt; <span class="number">0</span> || a &gt;= m || b &lt; <span class="number">0</span> || b &gt;= n) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span>(i == grid[x][y]) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(dist[a][b] &gt; dist[x][y]) &#123;</span><br><span class="line">                        q.<span class="built_in">push_front</span>(&#123;a, b&#125;);</span><br><span class="line">                        dist[a][b] = dist[x][y];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span>(dist[a][b] &gt; dist[x][y] + <span class="number">1</span>) &#123;</span><br><span class="line">                        q.<span class="built_in">push_back</span>(&#123;a, b&#125;);</span><br><span class="line">                        dist[a][b] = dist[x][y] + <span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;题目特点&quot;&gt;&lt;a href=&quot;#题目特点&quot; class=&quot;headerlink&quot; title=&quot;题目特点&quot;&gt;&lt;/a&gt;题目特点&lt;/h1&gt;&lt;p&gt;01bfs用来解决：边权值为0或1(非0即可)，时间复杂度O( v点+e边 )。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;主要思想&lt;/</summary>
      
    
    
    
    <category term="算法" scheme="https://xielingfan.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="图论" scheme="https://xielingfan.github.io/tags/%E5%9B%BE%E8%AE%BA/"/>
    
    <category term="最短路" scheme="https://xielingfan.github.io/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF/"/>
    
    <category term="bfs" scheme="https://xielingfan.github.io/tags/bfs/"/>
    
    <category term="双端队列" scheme="https://xielingfan.github.io/tags/%E5%8F%8C%E7%AB%AF%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>算法题总结——约瑟夫环</title>
    <link href="https://xielingfan.github.io/2022/05/28/%E7%AE%97%E6%B3%95%E9%A2%98%E6%80%BB%E7%BB%93%E2%80%94%E2%80%94%E7%BA%A6%E7%91%9F%E5%A4%AB%E7%8E%AF/"/>
    <id>https://xielingfan.github.io/2022/05/28/%E7%AE%97%E6%B3%95%E9%A2%98%E6%80%BB%E7%BB%93%E2%80%94%E2%80%94%E7%BA%A6%E7%91%9F%E5%A4%AB%E7%8E%AF/</id>
    <published>2022-05-28T00:45:42.000Z</published>
    <updated>2022-05-30T08:58:08.962Z</updated>
    
    <content type="html"><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>N个人围成一圈，从第一个开始报数，第M个将被杀掉，然后从下个人开始报数，最后剩下一个，其余人都将被杀掉。</p><h1 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h1><h2 id="约瑟夫环"><a href="#约瑟夫环" class="headerlink" title="约瑟夫环"></a>约瑟夫环</h2><h3 id="剑指-Offer-62-圆圈中最后剩下的数字"><a href="#剑指-Offer-62-圆圈中最后剩下的数字" class="headerlink" title="剑指 Offer 62. 圆圈中最后剩下的数字"></a><a href="https://leetcode.cn/problems/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-lcof/">剑指 Offer 62. 圆圈中最后剩下的数字</a></h3><p><strong>题目</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>,<span class="number">1</span>,···,n<span class="number">-1</span>这n个数字排成一个圆圈，从数字<span class="number">0</span>开始，每次从这个圆圈里删除第m个数字（删除后从下一个数字开始计数）。求出这个圆圈里剩下的最后一个数字。</span><br><span class="line"></span><br><span class="line">例如，<span class="number">0</span>、<span class="number">1</span>、<span class="number">2</span>、<span class="number">3</span>、<span class="number">4</span>这<span class="number">5</span>个数字组成一个圆圈，从数字<span class="number">0</span>开始每次删除第<span class="number">3</span>个数字，则删除的前<span class="number">4</span>个数字依次是<span class="number">2</span>、<span class="number">0</span>、<span class="number">4</span>、<span class="number">1</span>，因此最后剩下的数字是<span class="number">3</span>。</span><br></pre></td></tr></table></figure><p><strong>思路</strong></p><p>记f(n, m)为： 共n个数， 从下标0开始计数， 删除第m个数， 最后剩下的数字</p><p>删除1个数后， 下次从下标m开始， 还剩n-1个数</p><p>f(n, m) &#x3D; ( m + f(n-1, m) ) % n</p><p><strong>代码</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lastRemaining</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> m)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> (m + <span class="built_in">lastRemaining</span>(n<span class="number">-1</span>, m)) % n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="1823-找出游戏的获胜者"><a href="#1823-找出游戏的获胜者" class="headerlink" title="1823. 找出游戏的获胜者"></a><a href="https://leetcode.cn/problems/find-the-winner-of-the-circular-game/">1823. 找出游戏的获胜者</a></h3><p>与上一题区别为下表从1开始</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findTheWinner</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">help</span>(n, k) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下标从0开始</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">help</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> m)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> (m + <span class="built_in">help</span>(n<span class="number">-1</span>, m)) % n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="约瑟夫环应用"><a href="#约瑟夫环应用" class="headerlink" title="约瑟夫环应用"></a>约瑟夫环应用</h2><h3 id="390-消除游戏"><a href="#390-消除游戏" class="headerlink" title="390. 消除游戏"></a><a href="https://leetcode.cn/problems/elimination-game/">390. 消除游戏</a></h3><p><strong>题目</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">列表 arr 由在范围 [1, n] 中的所有整数组成，并按严格递增排序。请你对 arr 应用下述算法：</span><br><span class="line"></span><br><span class="line">从左到右，删除第一个数字，然后每隔一个数字删除一个，直到到达列表末尾。</span><br><span class="line">重复上面的步骤，但这次是从右到左。也就是，删除最右侧的数字，然后剩下的数字每隔一个删除一个。</span><br><span class="line">不断重复这两步，从左到右和从右到左交替进行，直到只剩下一个数字。</span><br><span class="line">给你整数 n ，返回 arr 最后剩下的数字。</span><br></pre></td></tr></table></figure><p><strong>思路</strong></p><p>记f(n)为第一次为从左到右删除， 剩下的最后一个数字；g(n)为第一次为从右到左删除，  剩下的最后一个数字。</p><ul><li>结论一：f(n) + g(n) &#x3D; n+1， 因为f(n)和g(n)对称</li><li>结论二：f(n) &#x3D; g(n&#x2F;2) * 2</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1 2 3 4 5 6 7 8 9 10</span><br><span class="line">从左到右删除一次后为： 2 4 6 8 10</span><br><span class="line">除以2:  1 2 3 4 5</span><br><span class="line">g(5) * 2 即为 f(10)</span><br></pre></td></tr></table></figure><p>推出f(n) &#x3D; 2 * ( n&#x2F;2 + 1 - f(n&#x2F;2)  )</p><p><strong>代码</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lastRemaining</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> n == <span class="number">1</span> ? <span class="number">1</span> : <span class="number">2</span> * (n / <span class="number">2</span> + <span class="number">1</span> - <span class="built_in">lastRemaining</span>(n / <span class="number">2</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h1&gt;&lt;p&gt;N个人围成一圈，从第一个开始报数，第M个将被杀掉，然后从下个人开始报数，最后剩下一个，其余人都将被杀掉。&lt;/p&gt;
&lt;h1 i</summary>
      
    
    
    
    <category term="算法" scheme="https://xielingfan.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="约瑟夫环" scheme="https://xielingfan.github.io/tags/%E7%BA%A6%E7%91%9F%E5%A4%AB%E7%8E%AF/"/>
    
  </entry>
  
  <entry>
    <title>分布式</title>
    <link href="https://xielingfan.github.io/2022/05/24/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    <id>https://xielingfan.github.io/2022/05/24/%E5%88%86%E5%B8%83%E5%BC%8F/</id>
    <published>2022-05-24T13:25:48.000Z</published>
    <updated>2022-05-28T00:45:48.132Z</updated>
    
    <content type="html"><![CDATA[<h1 id="汇总"><a href="#汇总" class="headerlink" title="汇总"></a>汇总</h1><p>IMABCDE 这 7 个字母所代表的 IoT 物联网、Mobile 移动计算、AI 人工智能、Blockchain 区块链、Cloud 云计算、Data 大数据、Edge 边缘计算，也无不都是以分布式技术为基石。</p><p><img src="D:\blog\my-blog\source\img\62b5acf80f49fe8d1a8b229df36f00e9.webp" alt="62b5acf80f49fe8d1a8b229df36f00e9"></p><p>1：为什么说没有分布式技术就没有BATJTMD？ </p><p>2：没有分布式技术之前的网络世界是怎样的？ </p><p>3：分布式技术是怎么催生的，又是怎么发展的？ </p><p>4：分布式技术解决了什么痛点问题？ </p><p>5：分布式解决的痛点问题又是怎么产生的？ </p><p>6：分布式技术的基础是啥？ </p><p>7：分布式技术的核心原理是啥？ </p><p>8：分布式技术解决问题的同时有带来了那些痛点？ </p><p>9：分布式技术带来的问题又是怎么解决的？ OK，学完本专栏，如果这些问题都清楚了，那就不白花钱。 </p><p>我现在的理解，分布式本质意思就是多个的意思，多个啥呢？直观感受就是多个电脑，至少有两台吧！为啥需要多个电脑？因为一个电脑不行，不能解决问题，不能解决啥问题？不能解决存储的问题，它空间有限，假如一台电脑的容量是无限的还有问题吗？还有的，还有就是性能问题，假如一台电脑容量无限计算数据和移动数据不需要时间立马就能完成呢？如果假设成立，我真不知道世界上还需要两台电脑的原因是什么？可能是防止这台电脑坏了吧！ OK，我的观点是 1：分布式解决的痛点问题就是单机容量和性能所形成的瓶颈问题。 2：分布式的核心原理就是一台电脑不行就来两台，其他的一切都是围绕怎么把两台电脑像一台电脑一样来使用未出发点来展开了。 3：分布式的系统把N台电脑幻化成了一台超级电脑，他的容量无限性能极佳斗转星移永不宕机。</p><p>四横四纵，横着就是大数据的日常，资源，通信，存储，计算，竖着就是运维和架构关心的协同，调度，高可用，可扩展(或者说部署)</p><p>四横四纵，精辟。 四横：在一定的分布式资源上进行分布式通信，然后通过分布式计算的处理结果，落到分布式存储上； 四纵：在构建分布式系统时，总要关注分布式协同、分布式调度、分布式高可用追踪和分布式部署。</p><p>我自底向上按照资源、通信、数据与计算的维度，梳理出了 4 个技术层次：分布式资源池化、分布式通信、分布式数据存储与管理、分布式计算。这样的划分符合业务架构设计的一般规律，即“在一定资源上，进行一定通信，通过一定计算，完成一定数据的加工和处理，从而对外提供特定的服务”。另一方面，这样的划分也整合了零散的知识点，具有完备性。</p><p>在分布式环境下，无论是资源、通信、数据还是计算，都需要去解决协同、调度、追踪高可用，还有部署的问题。</p><h3 id="缘起：-单兵、游击队、集团军"><a href="#缘起：-单兵、游击队、集团军" class="headerlink" title="缘起： 单兵、游击队、集团军"></a>缘起： 单兵、游击队、集团军</h3><p>单机模式所有的存储、计算都在一台计算机上， 硬件性能有限，且需要考虑升级硬件成本</p><p>单机模式的主要问题是：<strong>性能受限</strong>、存在<strong>单点失效问题</strong>。</p><p>游击队模式：<strong>数据并行</strong>或数据分布式</p><p><strong>并行计算</strong>采用消息共享模式使用多台计算机并行运行或执行多项任务，核心原理是每台计算机上执行相同的程序，将数据进行拆分放到不同的计算机上进行计算。</p><p>解决了单机模式的计算效率瓶颈问题。但这种模式仍然存在如下几个问题，在实际应用中，我们需要对其进行相应的优化：相同的应用部署到不同的服务器上，当大量用户请求过来时，如何能比较均衡地转发到不同的应用服务器上呢？解决这个问题的方法是设计一个负载均衡器，我会在“分布式高可靠”模块与你讲述负载均衡的相关原理。当请求量较大时，对数据库的频繁读写操作，使得数据库的 IO 访问成为瓶颈。解决这个问题的方式是读写分离，读数据库只接收读请求，写数据库只接收写请求，当然读写数据库之间要进行数据同步，以保证数据一致性。当有些数据成为热点数据时，会导致数据库访问频繁，压力增大。解决这个问题的方法是引入缓存机制，将热点数据加载到缓存中，一方面可以减轻数据库的压力，另一方面也可以提升查询效率。</p><p>数据并行模式的主要问题是：对提升单个任务的执行性能及降低时延无效。</p><p><strong>任务并行</strong>指的是，将单个复杂的任务拆分为多个子任务，从而使得多个子任务可以在不同的计算机上并行执行。</p><p>集团军模式在提供了更好的性能、扩展性、可维护性的同时，也带来了设计上的复杂性问题</p><p>分布式其实就是将相同或相关的程序运行在多台计算机上，从而实现特定目标的一种计算方式。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;汇总&quot;&gt;&lt;a href=&quot;#汇总&quot; class=&quot;headerlink&quot; title=&quot;汇总&quot;&gt;&lt;/a&gt;汇总&lt;/h1&gt;&lt;p&gt;IMABCDE 这 7 个字母所代表的 IoT 物联网、Mobile 移动计算、AI 人工智能、Blockchain 区块链、Cloud 云</summary>
      
    
    
    
    <category term="分布式" scheme="https://xielingfan.github.io/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
    <category term="分布式" scheme="https://xielingfan.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>算法题总结——计算贡献</title>
    <link href="https://xielingfan.github.io/2022/05/22/%E7%AE%97%E6%B3%95%E9%A2%98%E6%80%BB%E7%BB%93%E2%80%94%E2%80%94%E8%AE%A1%E7%AE%97%E8%B4%A1%E7%8C%AE/"/>
    <id>https://xielingfan.github.io/2022/05/22/%E7%AE%97%E6%B3%95%E9%A2%98%E6%80%BB%E7%BB%93%E2%80%94%E2%80%94%E8%AE%A1%E7%AE%97%E8%B4%A1%E7%8C%AE/</id>
    <published>2022-05-22T14:00:34.000Z</published>
    <updated>2022-05-23T07:04:58.157Z</updated>
    
    <content type="html"><![CDATA[<h1 id="计算贡献类型的题目特点"><a href="#计算贡献类型的题目特点" class="headerlink" title="计算贡献类型的题目特点"></a>计算贡献类型的题目特点</h1><p>题目一般会给出一个数组（或字符串）， 求所有子数组（子串）或子序列 按照特定要求所求值的总和。</p><p><strong>思路</strong>： 可以求每个元素对最后答案的贡献值， 然后累加。</p><h1 id="例题总结"><a href="#例题总结" class="headerlink" title="例题总结"></a>例题总结</h1><h2 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h2><h3 id="828-统计子串中的唯一字符"><a href="#828-统计子串中的唯一字符" class="headerlink" title="828. 统计子串中的唯一字符"></a><a href="https://leetcode.cn/problems/count-unique-characters-of-all-substrings-of-a-given-string/">828. 统计子串中的唯一字符</a></h3><p><strong>题目</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">我们定义了一个函数 countUniqueChars(s) 来统计字符串 s 中的唯一字符，并返回唯一字符的个数。</span><br><span class="line"></span><br><span class="line">例如：s = &quot;LEETCODE&quot; ，则其中 &quot;L&quot;, &quot;T&quot;,&quot;C&quot;,&quot;O&quot;,&quot;D&quot; 都是唯一字符，因为它们只出现一次，所以 countUniqueChars(s) = 5 。</span><br><span class="line"></span><br><span class="line">本题将会给你一个字符串 s ，我们需要返回 countUniqueChars(t) 的总和，其中 t 是 s 的子字符串。注意，某些子字符串可能是重复的，但你统计时也必须算上这些重复的子字符串（也就是说，你必须统计 s 的所有子字符串中的唯一字符）。</span><br><span class="line"></span><br><span class="line">由于答案可能非常大，请将结果 mod 10 ^ 9 + 7 后再返回。</span><br></pre></td></tr></table></figure><p><strong>思路</strong></p><p>计算每个元素的贡献，即所有s[i]是唯一字符的子串数量， 累加每个元素的贡献就是最终答案。</p><p>通过两次遍历：一次从左往右， 一次从右往左，利用哈希表记录上一次每个字母上次出现的位置。</p><p><strong>代码</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e9</span> + <span class="number">7</span>; </span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">uniqueLetterString</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算s[i]为唯一字符的子串左右界</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">L</span><span class="params">(n, <span class="number">-1</span>)</span>, <span class="title">R</span><span class="params">(n, n)</span></span>;</span><br><span class="line">        unordered_map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; mp;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(mp.<span class="built_in">count</span>(s[i])) L[i] = mp[s[i]];</span><br><span class="line">            mp[s[i]] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        mp.<span class="built_in">clear</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = n<span class="number">-1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span>(mp.<span class="built_in">count</span>(s[i])) R[i] = mp[s[i]];</span><br><span class="line">            mp[s[i]] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 计算贡献</span></span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            LL l = L[i], r = R[i];</span><br><span class="line">            res = (res + (i-l) * (r-i)) % N;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="2262-字符串的总引力"><a href="#2262-字符串的总引力" class="headerlink" title="2262. 字符串的总引力"></a><a href="https://leetcode.cn/problems/total-appeal-of-a-string/">2262. 字符串的总引力</a></h3><p><strong>题目</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">字符串的 引力 定义为：字符串中 不同 字符的数量。</span><br><span class="line"></span><br><span class="line">例如，&quot;abbca&quot; 的引力为 3 ，因为其中有 3 个不同字符 &#x27;a&#x27;、&#x27;b&#x27; 和 &#x27;c&#x27; 。</span><br><span class="line">给你一个字符串 s ，返回 其所有子字符串的总引力 。</span><br><span class="line"></span><br><span class="line">子字符串 定义为：字符串中的一个连续字符序列。</span><br></pre></td></tr></table></figure><p><strong>思路</strong></p><p>考虑每新增一个字符， 增加的子串贡献的引力值</p><p>例如字符串为 “defabcdef”</p><p>增加f后， 以f结尾的所有子串分为两类</p><p>（1）单独的”f”</p><p>（2） 以上一个字符e结尾的所有子串末尾加一个f。</p><p>“ef”,  “edf”, “cdef”, “bcdef”, “abcdef”, “fabcdef”, “efabcdef”,  “defabcdef”</p><p>假设上一步已经求出以e结尾所有子串的引力值总和为t</p><p>“e”,  “ed”, “cde”, “bcde”, “abcde”, “fabcde”, “efabcde”,  “defabcde”</p><p>这些字符串中有5个中不包含f，所以末尾加一个f后引力值加1， 其余字符串末尾加f后引力值不变</p><p>所以这些字符串末尾加一个f后的引力值总和为 t+5</p><p>所以  以f结尾的所有子串引力值为  1 + (t+5)。</p><p>那么如何知道以当前字符的上一个字符结尾的子串中，有几个是不含当前字符的呢？</p><p>只要记录每个字符上次出现的位置就可以</p><p>比如，遍历到下标8时是f， f上次出现的位置是2，  那么8-2-1 &#x3D; 5就可以得到目标值</p><table><thead><tr><th></th><th></th><th></th><th></th><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>0</td><td>1</td><td>2</td><td>3</td><td>4</td><td>5</td><td>6</td><td>7</td><td>8</td></tr><tr><td>d</td><td>e</td><td>f</td><td>a</td><td>b</td><td>c</td><td>d</td><td>e</td><td>f</td></tr></tbody></table><p><strong>代码</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">appealSum</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">L</span><span class="params">(n, <span class="number">-1</span>)</span></span>;</span><br><span class="line">        unordered_map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; mp;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>, t = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(mp.<span class="built_in">count</span>(s[i])) L[i] = mp[s[i]];</span><br><span class="line">            mp[s[i]] = i;</span><br><span class="line">            t += i - L[i];</span><br><span class="line">            res += t;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h2><h3 id="907-子数组的最小值之和"><a href="#907-子数组的最小值之和" class="headerlink" title="907. 子数组的最小值之和"></a><a href="https://leetcode.cn/problems/sum-of-subarray-minimums/">907. 子数组的最小值之和</a></h3><p><strong>题目</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">给定一个整数数组 arr，找到 min(b) 的总和，其中 b 的范围为 arr 的每个（连续）子数组。</span><br><span class="line">由于答案可能很大，因此 返回答案模 10^9 + 7 。</span><br></pre></td></tr></table></figure><p><strong>思路</strong></p><p>枚举最小值： 对于每个i ∈（1,n）, 找到所有以arr[i]作为最小值的子数组，数量为k， arr[i]的贡献为arr[i]*k，所有元素的贡献和就是最终答案。</p><p>注意： 为了保证子数组的最小值唯一（保证答案不重复），可以认为规定当i &lt; j 且arr[i] &#x3D; arr[j]时， 认为arr[i]更小。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">sumSubarrayMins</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = arr.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">l</span><span class="params">(n)</span>, <span class="title">r</span><span class="params">(n)</span></span>;</span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; stk;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span>(stk.<span class="built_in">size</span>() &amp;&amp; arr[stk.<span class="built_in">top</span>()] &gt; arr[i]) stk.<span class="built_in">pop</span>(); <span class="comment">//两个数相同时，规定左侧的更小</span></span><br><span class="line">            <span class="keyword">if</span>(stk.<span class="built_in">empty</span>()) l[i] = <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">else</span> l[i] = stk.<span class="built_in">top</span>();</span><br><span class="line">            stk.<span class="built_in">push</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        stk = <span class="built_in">stack</span>&lt;<span class="type">int</span>&gt;();  <span class="comment">// stack无clear()函数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = n<span class="number">-1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">while</span>(stk.<span class="built_in">size</span>() &amp;&amp; arr[stk.<span class="built_in">top</span>()] &gt;= arr[i]) stk.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span>(stk.<span class="built_in">empty</span>()) r[i] = n;</span><br><span class="line">            <span class="keyword">else</span> r[i] = stk.<span class="built_in">top</span>();</span><br><span class="line">            stk.<span class="built_in">push</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> N = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            res = (res + (LL)arr[i] * (i - l[i]) * (r[i] - i))%N; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="2104-子数组范围和"><a href="#2104-子数组范围和" class="headerlink" title="2104. 子数组范围和"></a><a href="https://leetcode.cn/problems/sum-of-subarray-ranges/">2104. 子数组范围和</a></h3><p><strong>题目</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">给你一个整数数组 nums 。nums 中，子数组的 范围 是子数组中最大元素和最小元素的差值。</span><br><span class="line">返回 nums 中 所有 子数组范围的 和 。</span><br><span class="line">子数组是数组中一个连续 非空 的元素序列。</span><br></pre></td></tr></table></figure><p><strong>思路</strong></p><p>范围和sum等于所有子数组的最大值之和maxSum减所有子数组的最小值之和minSum</p><p>所以问题转化为为<a href="https://leetcode-cn.com/problems/sum-of-subarray-minimums/">907. 子数组的最小值之和</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">subArrayRanges</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">minL</span><span class="params">(n)</span>, <span class="title">minR</span><span class="params">(n)</span>, <span class="title">maxL</span><span class="params">(n)</span>, <span class="title">maxR</span><span class="params">(n)</span></span>;</span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; stk1, stk2;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span>(stk1.<span class="built_in">size</span>() &amp;&amp; nums[stk1.<span class="built_in">top</span>()] &gt; nums[i]) stk1.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span>(stk1.<span class="built_in">empty</span>()) minL[i] = <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">else</span> minL[i] = stk1.<span class="built_in">top</span>();</span><br><span class="line">            stk1.<span class="built_in">push</span>(i);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(stk2.<span class="built_in">size</span>() &amp;&amp; nums[stk2.<span class="built_in">top</span>()] &lt;= nums[i]) stk2.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span>(stk2.<span class="built_in">empty</span>()) maxL[i] = <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">else</span> maxL[i] = stk2.<span class="built_in">top</span>();</span><br><span class="line">            stk2.<span class="built_in">push</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        stk1 = <span class="built_in">stack</span>&lt;<span class="type">int</span>&gt;(), stk2 = <span class="built_in">stack</span>&lt;<span class="type">int</span>&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = n<span class="number">-1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">while</span>(stk1.<span class="built_in">size</span>() &amp;&amp; nums[stk1.<span class="built_in">top</span>()] &gt;= nums[i]) stk1.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span>(stk1.<span class="built_in">empty</span>()) minR[i] = n;</span><br><span class="line">            <span class="keyword">else</span> minR[i] = stk1.<span class="built_in">top</span>();</span><br><span class="line">            stk1.<span class="built_in">push</span>(i);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(stk2.<span class="built_in">size</span>() &amp;&amp; nums[stk2.<span class="built_in">top</span>()] &lt; nums[i]) stk2.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span>(stk2.<span class="built_in">empty</span>()) maxR[i] = n;</span><br><span class="line">            <span class="keyword">else</span> maxR[i] = stk2.<span class="built_in">top</span>();</span><br><span class="line">            stk2.<span class="built_in">push</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line">        LL res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            res += (LL)nums[i] * (i - maxL[i]) * (maxR[i] - i);</span><br><span class="line">            res -= (LL)nums[i] * (i - minL[i]) * (minR[i] - i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure><h2 id="单调栈-前缀和"><a href="#单调栈-前缀和" class="headerlink" title="单调栈 + 前缀和"></a>单调栈 + 前缀和</h2><h3 id="2281-巫师的总力量和"><a href="#2281-巫师的总力量和" class="headerlink" title="2281. 巫师的总力量和"></a><a href="https://leetcode.cn/problems/sum-of-total-strength-of-wizards/">2281. 巫师的总力量和</a></h3><p><strong>题目</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">作为国王的统治者，你有一支巫师军队听你指挥。</span><br><span class="line"></span><br><span class="line">给你一个下标从 0 开始的整数数组 strength ，其中 strength[i] 表示第 i 位巫师的力量值。对于连续的一组巫师（也就是这些巫师的力量值是 strength 的 子数组），总力量 定义为以下两个值的 乘积 ：</span><br><span class="line"></span><br><span class="line">巫师中 最弱 的能力值。</span><br><span class="line">组中所有巫师的个人力量值 之和 。</span><br><span class="line">请你返回 所有 巫师组的 总 力量之和。由于答案可能很大，请将答案对 109 + 7 取余 后返回。</span><br><span class="line"></span><br><span class="line">子数组 是一个数组里 非空 连续子序列。</span><br></pre></td></tr></table></figure><p><strong>思路</strong></p><p>所有子数组的加权和&#x3D;以第一个数为最小值的子数组和<em>第一个数+以第二个数为最小值的子数组和</em>第二个数+…+以第最后一个数为最小值的子数组和*最后一个数<br>$$<br>\begin{aligned}<br>&amp;\sum_{r&#x3D;i+1}^{R+1}\sum_{l&#x3D;L}^is[r] - s[l]\\<br>&amp;&#x3D;\sum_{r&#x3D;i+1}^{R+1}((i-L+1)*s[r] -  \sum_{l&#x3D;L}^is[l])\\<br>&amp;&#x3D;(i-L+1)\sum_{r&#x3D;i+1}^{R+1}s[r] - (R-i+1)\sum_{l&#x3D;L}^is[l]<br>\end{aligned}<br>$$<br><strong>代码</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">totalStrength</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 单调栈求元素左右第一个比自己小的位置</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">minL</span><span class="params">(n, <span class="number">-1</span>)</span>, <span class="title">minR</span><span class="params">(n, n)</span></span>;</span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; stk;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span>(stk.<span class="built_in">size</span>() &amp;&amp; nums[stk.<span class="built_in">top</span>()] &gt; nums[i]) stk.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span>(stk.<span class="built_in">size</span>()) minL[i] = stk.<span class="built_in">top</span>();</span><br><span class="line">            stk.<span class="built_in">push</span>(i); </span><br><span class="line">        &#125;</span><br><span class="line">        stk = <span class="built_in">stack</span>&lt;<span class="type">int</span>&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = n<span class="number">-1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">while</span>(stk.<span class="built_in">size</span>() &amp;&amp; nums[stk.<span class="built_in">top</span>()] &gt;= nums[i]) stk.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span>(stk.<span class="built_in">size</span>()) minR[i] = stk.<span class="built_in">top</span>();</span><br><span class="line">            stk.<span class="built_in">push</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 前缀和的前缀和</span></span><br><span class="line">        LL sum = <span class="number">0</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">SS</span><span class="params">(n+<span class="number">2</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            sum += nums[i<span class="number">-1</span>];</span><br><span class="line">            SS[i+<span class="number">1</span>] = (SS[i] + sum) % N;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 计算贡献</span></span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            LL l = minL[i] + <span class="number">1</span>, r = minR[i] - <span class="number">1</span>;</span><br><span class="line">            LL totalSum = ((i-l+<span class="number">1</span>) * (SS[r+<span class="number">2</span>]-SS[i+<span class="number">1</span>]) - (r-i+<span class="number">1</span>) * (SS[i+<span class="number">1</span>]-SS[l])) % N;</span><br><span class="line">            res = (res + nums[i]*totalSum) % N;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (res+N)%N;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="排序-二分"><a href="#排序-二分" class="headerlink" title="排序 + 二分"></a>排序 + 二分</h2><h3 id="1498-满足条件的子序列数目"><a href="#1498-满足条件的子序列数目" class="headerlink" title="1498. 满足条件的子序列数目"></a><a href="https://leetcode.cn/problems/number-of-subsequences-that-satisfy-the-given-sum-condition/">1498. 满足条件的子序列数目</a></h3><p><strong>题目</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">给你一个整数数组 nums 和一个整数 target 。</span><br><span class="line"></span><br><span class="line">请你统计并返回 nums 中能满足其最小元素与最大元素的 和 小于或等于 target 的 非空 子序列的数目。</span><br><span class="line"></span><br><span class="line">由于答案可能很大，请将结果对 109 + 7 取余后返回。</span><br></pre></td></tr></table></figure><p><strong>思路</strong></p><p>题目是子序列， 而且只关注子序列的最值，所以答案与元素顺序无关，可以先排序，便于二分。 </p><p>枚举以nums[i]作为最小值的所有子序列中， 满足最小元素与最大元素的 和 小于或等于 target的数目。 因为有序，所以右边界可以二分， 设右边界为r，子序列数目为 pow(2, r-i), 可以用快速幂求解。</p><p><strong>代码</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">numSubseq</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="type">int</span> l = i, r = n<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">while</span>(l &lt; r) &#123;</span><br><span class="line">                <span class="type">int</span> mid = l + r + <span class="number">1</span> &gt;&gt; <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(nums[i] + nums[mid] &lt;= target) l = mid;</span><br><span class="line">                <span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] + nums[l] &gt; target) <span class="keyword">break</span>;</span><br><span class="line">            res = (res + <span class="built_in">qmi</span>(<span class="number">2</span>, l-i, N)) % N;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">qmi</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> k, <span class="type">int</span> p)</span> </span>&#123;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> res = <span class="number">1</span>, base = m;</span><br><span class="line">        <span class="keyword">while</span>(k) &#123;</span><br><span class="line">            <span class="keyword">if</span>(k&amp;<span class="number">1</span>) res = res * base % p;</span><br><span class="line">            base = base * base % p;</span><br><span class="line">            k &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;计算贡献类型的题目特点&quot;&gt;&lt;a href=&quot;#计算贡献类型的题目特点&quot; class=&quot;headerlink&quot; title=&quot;计算贡献类型的题目特点&quot;&gt;&lt;/a&gt;计算贡献类型的题目特点&lt;/h1&gt;&lt;p&gt;题目一般会给出一个数组（或字符串）， 求所有子数组（子串）或子序列 </summary>
      
    
    
    
    <category term="算法" scheme="https://xielingfan.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="单调栈" scheme="https://xielingfan.github.io/tags/%E5%8D%95%E8%B0%83%E6%A0%88/"/>
    
    <category term="前缀和" scheme="https://xielingfan.github.io/tags/%E5%89%8D%E7%BC%80%E5%92%8C/"/>
    
    <category term="哈希" scheme="https://xielingfan.github.io/tags/%E5%93%88%E5%B8%8C/"/>
    
  </entry>
  
  <entry>
    <title>redis数据结构</title>
    <link href="https://xielingfan.github.io/2022/05/21/redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    <id>https://xielingfan.github.io/2022/05/21/redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</id>
    <published>2022-05-21T14:57:46.000Z</published>
    <updated>2022-06-13T16:04:56.816Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简单动态字符串"><a href="#简单动态字符串" class="headerlink" title="简单动态字符串"></a>简单动态字符串</h1><p>简单动态字符转（simple dynamic string， SDS）</p><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span> &#123;</span></span><br><span class="line">    <span class="comment">// 记录buf数组中已使用的字节数量</span></span><br><span class="line">    <span class="comment">// 等于SDS锁保存字符串的长度</span></span><br><span class="line">    <span class="type">int</span> len;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 记录buf数组中未使用字节的数量</span></span><br><span class="line">    <span class="type">int</span> <span class="built_in">free</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 字节数组，用于保存字符串</span></span><br><span class="line">    <span class="type">char</span> buf[];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/../img/redis-sds.png" alt="redis-sds"></p><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><h3 id="常数时间复杂度获取字符串长度"><a href="#常数时间复杂度获取字符串长度" class="headerlink" title="常数时间复杂度获取字符串长度"></a>常数时间复杂度获取字符串长度</h3><p>C字符串不记录长度，所以或取长度需要O(n)时间复杂度， 而SDS可以直接读取<strong>len</strong>来O(1)的获取长度，提高性能。</p><p><strong>len</strong>是由设置、更新SDS的API维护的，无需手动维护。</p><h3 id="杜绝缓冲溢出"><a href="#杜绝缓冲溢出" class="headerlink" title="杜绝缓冲溢出"></a>杜绝缓冲溢出</h3><p>C字符串不记录长度，容易缓冲区溢出。 如&lt;string.h&gt;&#x2F;<a href="https://en.cppreference.com/w/cpp/string/byte/strcat">strcat</a>函数可以将字符串src拼接到dest末尾， 如果dest不足以容纳src，将造成缓冲区溢出。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *<span class="title function_">strcat</span><span class="params">( <span class="type">char</span> *dest, <span class="type">const</span> <span class="type">char</span> *src )</span>;</span><br></pre></td></tr></table></figure><p>SDS的API（如sdscat）在修改SDS时，会先检查SDS空间是否满足要求，不满足则自动扩容，然后再执行操作。</p><h3 id="减少内存重分配次数"><a href="#减少内存重分配次数" class="headerlink" title="减少内存重分配次数"></a>减少内存重分配次数</h3><p>Redis数据应用于性能要求高、数据修改频繁的场合， 所以希望内存分配次数尽可能的少。</p><p>SDS通过未使用空间<strong>free</strong>来对字符串长度与底层数组长度解耦， 实现了两种空间分配策略：预分配、 惰性释放。</p><p><strong>预分配</strong>：当SDS需要扩容时，程序不仅会分配需要的空间，还会额外分配未使用空间。如果修改后的<strong>len</strong>小于1MB， 那么程序分配和<strong>len</strong>同样大小的<strong>free</strong>；</p><p>如果修改后的<strong>len</strong>大于等于1MB， 那么程序分配和1MB的<strong>free</strong>。</p><p><strong>惰性释放</strong>：当SDS需要缩短保存的字符串时，并不会立即回收多出来的字节，而是使用free将多出的字节数记录起来，等待将来使用。SDS也提供了用于真正释放未使用空间的API。</p><h3 id="二进制安全"><a href="#二进制安全" class="headerlink" title="二进制安全"></a>二进制安全</h3><h3 id="兼容部分C字符串函数"><a href="#兼容部分C字符串函数" class="headerlink" title="兼容部分C字符串函数"></a>兼容部分C字符串函数</h3>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;简单动态字符串&quot;&gt;&lt;a href=&quot;#简单动态字符串&quot; class=&quot;headerlink&quot; title=&quot;简单动态字符串&quot;&gt;&lt;/a&gt;简单动态字符串&lt;/h1&gt;&lt;p&gt;简单动态字符转（simple dynamic string， SDS）&lt;/p&gt;
&lt;h2 id=&quot;定义</summary>
      
    
    
    
    
    <category term="redis" scheme="https://xielingfan.github.io/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>红包算法</title>
    <link href="https://xielingfan.github.io/2022/04/28/%E7%BA%A2%E5%8C%85%E7%AE%97%E6%B3%95/"/>
    <id>https://xielingfan.github.io/2022/04/28/%E7%BA%A2%E5%8C%85%E7%AE%97%E6%B3%95/</id>
    <published>2022-04-28T06:43:26.000Z</published>
    <updated>2022-06-13T16:04:29.962Z</updated>
    
    <content type="html"><![CDATA[<h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><p>设计一个微信拼手气红包算法</p><ul><li>需要保证每个红包金额的期望大致相等</li><li>每个红包最少为0.01元</li></ul><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>记当前剩余金额为M，剩余红包数为N， 每个红包的期望为M&#x2F;N， 所以第一个红包应该满足0.01~ 2*M&#x2F;N的均匀分布。 </p><p>计算当前红包时，为确保之后每个红包至少0.01元， 需要预留(N-1) * 0.01元， 即M先减(N-1) * 0.01再做上述计算。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RedEnvelope</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">double</span> money;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">RedEnvelope</span>(<span class="type">double</span> money, <span class="type">int</span> n) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;money = money;</span><br><span class="line">        <span class="keyword">this</span>-&gt;n = n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">GetMoney</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!n) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">1</span>) &#123;</span><br><span class="line">            n--;</span><br><span class="line">            <span class="keyword">return</span> money;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">double</span> e = (money - <span class="number">0.01</span>*(n<span class="number">-1</span>)) / n;</span><br><span class="line">        <span class="type">double</span> res = (<span class="type">double</span>)(<span class="built_in">rand</span>()%(<span class="type">int</span>)(<span class="built_in">round</span>(e*<span class="number">100</span>*<span class="number">2</span>)) + <span class="number">1</span>) / <span class="number">100</span>;</span><br><span class="line">        money -= res;</span><br><span class="line">        n--;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">(<span class="type">double</span> money, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">srand</span>((<span class="type">unsigned</span>)<span class="built_in">time</span>(<span class="number">0</span>));</span><br><span class="line">    RedEnvelope redEnvelope = <span class="built_in">RedEnvelope</span>(money, n);</span><br><span class="line">    <span class="type">double</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">auto</span> x = redEnvelope.<span class="built_in">GetMoney</span>();</span><br><span class="line">        sum += x;</span><br><span class="line">        cout &lt;&lt; x  &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl &lt;&lt; sum &lt;&lt; endl &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">test</span>(<span class="number">0.03</span>, <span class="number">2</span>);</span><br><span class="line">    <span class="built_in">test</span>(<span class="number">0.04</span>, <span class="number">2</span>);</span><br><span class="line">    <span class="built_in">test</span>(<span class="number">10</span>, <span class="number">7</span>);</span><br><span class="line">    <span class="built_in">test</span>(<span class="number">100</span>, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="测试输出"><a href="#测试输出" class="headerlink" title="测试输出"></a>测试输出</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">0.02 0.01 </span><br><span class="line">0.03</span><br><span class="line"></span><br><span class="line">0.02 0.02 </span><br><span class="line">0.04</span><br><span class="line"></span><br><span class="line">0.42 2.45 1.57 1.88 2.2 1.17 0.31 </span><br><span class="line">10</span><br><span class="line"></span><br><span class="line">27.5 26.69 18.61 6.69 20.51 </span><br><span class="line">100</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;问题&quot;&gt;&lt;a href=&quot;#问题&quot; class=&quot;headerlink&quot; title=&quot;问题&quot;&gt;&lt;/a&gt;问题&lt;/h4&gt;&lt;p&gt;设计一个微信拼手气红包算法&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;需要保证每个红包金额的期望大致相等&lt;/li&gt;
&lt;li&gt;每个红包最少为0.01元&lt;/li</summary>
      
    
    
    
    
    <category term="面试常见问题" scheme="https://xielingfan.github.io/tags/%E9%9D%A2%E8%AF%95%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>算法题总结——买卖股票问题</title>
    <link href="https://xielingfan.github.io/2022/04/28/%E7%AE%97%E6%B3%95%E9%A2%98%E6%80%BB%E7%BB%93%E2%80%94%E2%80%94%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E9%97%AE%E9%A2%98/"/>
    <id>https://xielingfan.github.io/2022/04/28/%E7%AE%97%E6%B3%95%E9%A2%98%E6%80%BB%E7%BB%93%E2%80%94%E2%80%94%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E9%97%AE%E9%A2%98/</id>
    <published>2022-04-28T02:58:11.000Z</published>
    <updated>2022-05-22T14:02:09.755Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目1——初始资金有限，每天最多买或卖一手，持有股票数不限，无手续费"><a href="#题目1——初始资金有限，每天最多买或卖一手，持有股票数不限，无手续费" class="headerlink" title="题目1——初始资金有限，每天最多买或卖一手，持有股票数不限，无手续费"></a>题目1——初始资金有限，每天最多买或卖一手，持有股票数不限，无手续费</h3><p>长度为n的价格数组a，表示某只股票每天的价格， 每天最多买入或卖出该只股票的1手股票， 无手续费， 卖出前手中必须有股票， 持有股票数目不受限制， 初始资金为m元， 任意时刻都不能透支。 请问在n天结束后，拥有最大的总资产是多少？（总资产： 股票数目*股票价格+现金）</p><p><strong>输入</strong>：<br>第一行两个正整数n，m(1 &lt;&#x3D; n &lt;&#x3D; 2000, 1 &lt;&#x3D; m &lt;&#x3D; 10^9)<br>第二行n个正整数ai (1 &lt;&#x3D; ai &lt;&#x3D; 1^9)， ai表示股票在第i天的售价</p><p><strong>输出</strong>：<br>n天结束后，拥有最大的总资产</p><p><strong>示例1</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">6 2</span><br><span class="line">2 3 1 1 1 2</span><br><span class="line">输出：</span><br><span class="line">6</span><br></pre></td></tr></table></figure><p><strong>示例2</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">3 2</span><br><span class="line">1 1 4</span><br><span class="line">输出：</span><br><span class="line">8</span><br></pre></td></tr></table></figure><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>dp</p><p><strong>状态表示</strong>： f(i,j) &#x3D; 第i天，持有j股股票时的最大现金数</p><p><strong>状态转移</strong>：</p><p>每一天的操作有三种中取最大值：</p><ul><li>买: f(i,j) &#x3D; f(i-1, j-1) - a[i] </li><li>卖: f(i,j) &#x3D; f(i-1, j+1) + a[i] </li><li>不操作（不买不卖）:  f(i,j) &#x3D; f(i-1,j)</li></ul><p>买的前提是当日剩余现金 &gt;&#x3D; 当日价格</p><p>卖的前提是当日手中股票是&gt;&#x3D; 1</p><p><strong>最终答案</strong>：max( f(n, j) + j* a[n] ), j &#x3D; 0, 1, ……, n</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">nums</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) cin &gt;&gt; nums[i];</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">f</span>(n+<span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n+<span class="number">1</span>, <span class="number">-1</span>));</span><br><span class="line">    f[<span class="number">0</span>][<span class="number">0</span>] = m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt;= i; j++) &#123;</span><br><span class="line">            f[i][j] = f[i<span class="number">-1</span>][j];</span><br><span class="line">            <span class="keyword">if</span>(j+<span class="number">1</span> &lt;= i<span class="number">-1</span> &amp;&amp; f[i<span class="number">-1</span>][j+<span class="number">1</span>] != <span class="number">-1</span>) f[i][j] = <span class="built_in">max</span>(f[i][j], f[i<span class="number">-1</span>][j+<span class="number">1</span>] + nums[i<span class="number">-1</span>]);</span><br><span class="line">            <span class="keyword">if</span>(j<span class="number">-1</span> &gt;= <span class="number">0</span> &amp;&amp;  f[i<span class="number">-1</span>][j<span class="number">-1</span>] &gt;= nums[i<span class="number">-1</span>]) f[i][j] = <span class="built_in">max</span>(f[i][j], f[i<span class="number">-1</span>][j<span class="number">-1</span>] - nums[i<span class="number">-1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt;= n; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(f[n][j] != <span class="number">-1</span>) res = <span class="built_in">max</span>(res, f[n][j] + j*nums[n<span class="number">-1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><h3 id="题目2——初始资金无限，每天最多买或卖一手，最多持有1手，有手续费"><a href="#题目2——初始资金无限，每天最多买或卖一手，最多持有1手，有手续费" class="headerlink" title="题目2——初始资金无限，每天最多买或卖一手，最多持有1手，有手续费"></a>题目2——初始资金无限，每天最多买或卖一手，最多持有1手，有手续费</h3><h4 id="714-买卖股票的最佳时机含手续费"><a href="#714-买卖股票的最佳时机含手续费" class="headerlink" title="714. 买卖股票的最佳时机含手续费"></a><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/">714. 买卖股票的最佳时机含手续费</a></h4><h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><p>dp</p><p><strong>状态表示</strong>： f(i,j) &#x3D; 第i天，持有j手股票时的最大现金数, j &#x3D; 0或1</p><p><strong>状态转移</strong>：</p><p>第i天持有0手， 可以是第 i-1天就持有0手第 i 天不操作， 或者是 i-1天持有 1 手第 i 天卖掉</p><p>第i天持有1手， 可以是第 i-1天就持有1手第 i 天不操作， 或者是 i-1天持有 0 手第 i 天买 1 手</p><p>f(i, 0) &#x3D; max( f(i-1, 0), f(i-1, 1) + prices[i] - fee )</p><p>f(i, 1) &#x3D; max( f(i-1, 1), f(i-1, 0) - prices[i]  )</p><h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices, <span class="type">int</span> fee)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = prices.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">f</span>(n, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">2</span>));</span><br><span class="line">        f[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>, f[<span class="number">0</span>][<span class="number">1</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            f[i][<span class="number">0</span>] = <span class="built_in">max</span>(f[i<span class="number">-1</span>][<span class="number">0</span>], f[i<span class="number">-1</span>][<span class="number">1</span>] + prices[i] - fee);</span><br><span class="line">            f[i][<span class="number">1</span>] = <span class="built_in">max</span>(f[i<span class="number">-1</span>][<span class="number">1</span>], f[i<span class="number">-1</span>][<span class="number">0</span>] - prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">return</span> f[n<span class="number">-1</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;题目1——初始资金有限，每天最多买或卖一手，持有股票数不限，无手续费&quot;&gt;&lt;a href=&quot;#题目1——初始资金有限，每天最多买或卖一手，持有股票数不限，无手续费&quot; class=&quot;headerlink&quot; title=&quot;题目1——初始资金有限，每天最多买或卖一手，持有</summary>
      
    
    
    
    <category term="算法" scheme="https://xielingfan.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="dp" scheme="https://xielingfan.github.io/tags/dp/"/>
    
  </entry>
  
  <entry>
    <title>字符串匹配——kmp算法</title>
    <link href="https://xielingfan.github.io/2022/04/26/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%E2%80%94%E2%80%94kmp%E7%AE%97%E6%B3%95/"/>
    <id>https://xielingfan.github.io/2022/04/26/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%E2%80%94%E2%80%94kmp%E7%AE%97%E6%B3%95/</id>
    <published>2022-04-26T14:45:33.000Z</published>
    <updated>2022-05-28T00:46:40.787Z</updated>
    
    <content type="html"><![CDATA[<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>s是主串，p是模式串，n是s的长度，m是p的长度, 下标从1开始。 求p是否在s中出现，或者出现多少次。</p><h3 id="暴力做法"><a href="#暴力做法" class="headerlink" title="暴力做法"></a>暴力做法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    <span class="type">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(s[i+j<span class="number">-1</span>] != p[j]) &#123;</span><br><span class="line">            flag = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(flag) <span class="comment">// 匹配</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>暴力匹配的思路：用模式串匹配主串的每一位，若从主串第i位开始匹配，匹配失败，则从主串第i+1位，模式串第1位重新匹配。</p><p>时间复杂度： 最坏O(n*m)</p><p>暴力做法的缺点：没有利用上次匹配失败时的有用信息，造成无用匹配。</p><h3 id="kmp算法思路"><a href="#kmp算法思路" class="headerlink" title="kmp算法思路"></a>kmp算法思路</h3><p>假设P从S的某处开始匹配， 绿色段为匹配成功的子串， 在红色处（i+1）匹配不成功。 蓝色部分是之后第一个成功的完整匹配</p><p>那么 由p1 &#x3D; s1、s1 &#x3D; p2可以推导出p1 &#x3D; p2， 即P[1,j]子串有相同的前后缀p1和p2。</p><p><img src="/../img/kmp.png" alt="kmp"></p><p>所以可以得到kmp算法的思路： 在知道p1&#x3D;p2的前提下， 在从绿色段开头k开始的这一轮匹配失败后，i可以不用回退到k+1，保持不变， j回退到p1子串的末尾即可， 因为通过上一轮失败匹配的信息可以得知s1 &#x3D; p2, 而 p1 &#x3D; p2, 所以s1 &#x3D; p1，可以直接从j+1开始继续匹配。</p><p>为了实现该算法，需要预处理出子串P(1,j) j &#x3D; 1,2,…,m 的最长相同前后缀长度， 即next数组。求“最长”相同前后缀是因为要防止j回退过多导致错过正确答案。</p><h3 id="如何求next数组"><a href="#如何求next数组" class="headerlink" title="如何求next数组"></a>如何求next数组</h3><p>求next数组的过程即P串从第二位开始与P串自身的匹配。匹配过程中，子串P(1,j) &#x3D; P’(1,j),   P’(1,j) &#x3D; P(i-j, i-1)， 得出P(1,j) &#x3D; P(i-j, i-1)， 即P(1,i-1)子串的最大相同前后缀长度为 j</p><p><img src="/../img/kmp2.png" alt="kmp2"></p><h3 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 求模式串的Next数组：</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>, j = <span class="number">0</span>; i &lt;= m; i ++ ) &#123;</span><br><span class="line">    <span class="keyword">while</span> (j &amp;&amp; p[i] != p[j + <span class="number">1</span>]) j = ne[j];</span><br><span class="line">    <span class="keyword">if</span> (p[i] == p[j + <span class="number">1</span>]) j ++ ;</span><br><span class="line">    ne[i] = j;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 匹配</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>, j = <span class="number">0</span>; i &lt;= n; i ++ ) &#123;</span><br><span class="line">    <span class="keyword">while</span> (j &amp;&amp; s[i] != p[j + <span class="number">1</span>]) j = ne[j];</span><br><span class="line">    <span class="keyword">if</span> (s[i] == p[j + <span class="number">1</span>]) j ++ ;</span><br><span class="line">    <span class="keyword">if</span> (j == m) &#123;</span><br><span class="line">        j = ne[j];</span><br><span class="line">        <span class="comment">// 匹配成功后的逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;问题&quot;&gt;&lt;a href=&quot;#问题&quot; class=&quot;headerlink&quot; title=&quot;问题&quot;&gt;&lt;/a&gt;问题&lt;/h3&gt;&lt;p&gt;s是主串，p是模式串，n是s的长度，m是p的长度, 下标从1开始。 求p是否在s中出现，或者出现多少次。&lt;/p&gt;
&lt;h3 id=&quot;暴力做法&quot;</summary>
      
    
    
    
    <category term="算法" scheme="https://xielingfan.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="kmp" scheme="https://xielingfan.github.io/tags/kmp/"/>
    
  </entry>
  
  <entry>
    <title>git基本操作</title>
    <link href="https://xielingfan.github.io/2022/04/26/git%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/"/>
    <id>https://xielingfan.github.io/2022/04/26/git%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/</id>
    <published>2022-04-26T04:06:28.000Z</published>
    <updated>2022-04-26T04:34:31.813Z</updated>
    
    <content type="html"><![CDATA[<h3 id="配置用户名、用户邮箱"><a href="#配置用户名、用户邮箱" class="headerlink" title="配置用户名、用户邮箱"></a>配置用户名、用户邮箱</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global [user.name](http://user.name/) <span class="string">&quot;Your Name&quot;</span>  </span><br><span class="line">git config --global [user.email](http://user.email/) <span class="string">&quot;email@[example.com](http://example.com/)&quot;</span></span><br></pre></td></tr></table></figure><h3 id="创建新目录并进入"><a href="#创建新目录并进入" class="headerlink" title="创建新目录并进入"></a>创建新目录并进入</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> learngit</span><br><span class="line"><span class="built_in">cd</span> learngit</span><br></pre></td></tr></table></figure><h3 id="将目录变成Git可管理的仓库"><a href="#将目录变成Git可管理的仓库" class="headerlink" title="将目录变成Git可管理的仓库"></a>将目录变成Git可管理的仓库</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure><h3 id="查看状态"><a href="#查看状态" class="headerlink" title="查看状态"></a>查看状态</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git status</span><br></pre></td></tr></table></figure><h3 id="工作区-Working-Directory-amp-暂存区-stage-x2F-index-amp-仓库（Repository）"><a href="#工作区-Working-Directory-amp-暂存区-stage-x2F-index-amp-仓库（Repository）" class="headerlink" title="工作区(Working Directory)&amp;暂存区(stage&#x2F;index)&amp;仓库（Repository）"></a>工作区(Working Directory)&amp;暂存区(stage&#x2F;index)&amp;仓库（Repository）</h3><p>工作区-&gt;暂存区    </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git add test.txt</span><br><span class="line">git add .</span><br></pre></td></tr></table></figure><p>暂存区-&gt;仓库     </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -m <span class="string">&quot;message&quot;</span></span><br></pre></td></tr></table></figure><p>查看工作区与暂存区差异 </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git diff</span><br></pre></td></tr></table></figure><p>  查看暂存区与仓库差异    </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git diff --cached</span><br></pre></td></tr></table></figure><p>查看工作区与仓库差异</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git diff HEAD</span><br></pre></td></tr></table></figure><h3 id="版本回退"><a href="#版本回退" class="headerlink" title="版本回退"></a>版本回退</h3><p>回退到上个版本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard HEAD^</span><br></pre></td></tr></table></figure><p>回退到上上个版本    </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard HEAD^^</span><br></pre></td></tr></table></figure><p>回退到上一百个版本    </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard HEAD~100</span><br></pre></td></tr></table></figure><p>回退到某一版本 </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard e5g1d(版本号前几位)</span><br></pre></td></tr></table></figure><p>参数</p><ul><li><p>3个区都回退    –hard</p></li><li><p>只回退仓库，暂存区和工作区不会发生变化    –soft</p></li><li><p>默认方式，回退暂存区和仓库信息，工作区不会发生变化    –mixed</p></li></ul><h3 id="撤销修改"><a href="#撤销修改" class="headerlink" title="撤销修改"></a>撤销修改</h3><p>撤销工作区的修改</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git restore test.txt</span><br><span class="line">git checkout -- test.txt</span><br></pre></td></tr></table></figure><p>撤销暂存区的变化&#x2F;撤销git add</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git restore --staged test.txt</span><br><span class="line">git reset  HEAD test.txt</span><br></pre></td></tr></table></figure><h3 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h3><p>所有提交的版本信息</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">log</span></span><br></pre></td></tr></table></figure><p>简略版日志</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">log</span> --pretty=oneline</span><br></pre></td></tr></table></figure><p>分支合并图、一行显示、提交校验码缩略显示</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">log</span> --pretty=oneline  --graph --abbrev-commit</span><br></pre></td></tr></table></figure><p>查看所有分支的操作记录（commit、reset），可用来恢复被删除版本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reflog </span><br></pre></td></tr></table></figure><h3 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h3><p>查看分支</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch</span><br></pre></td></tr></table></figure><p>创建分支</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch dev</span><br></pre></td></tr></table></figure><p>切换分支</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git switch dev</span><br><span class="line">git checkout dev</span><br></pre></td></tr></table></figure><p>创建+切换分支</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git switch -c dev</span><br><span class="line">git checkout -b dev</span><br></pre></td></tr></table></figure><p>合并某分支到当前分支</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git merge dev    #fast foward模式：删除分支后会丢掉分支信息</span><br><span class="line">git merge --no-ff -m &quot;message&quot; dev    #--no-ff 模式：会在merge时生成一个新的commit</span><br></pre></td></tr></table></figure><p>解决冲突，编辑文档解决冲突后</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">add + commit</span><br></pre></td></tr></table></figure><p>删除分支</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -d dev</span><br></pre></td></tr></table></figure><p>强制删除分支（若要删除没有被合并过的分支）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -D dev</span><br></pre></td></tr></table></figure><h3 id="应对突发情况，保存当前工作"><a href="#应对突发情况，保存当前工作" class="headerlink" title="应对突发情况，保存当前工作"></a>应对突发情况，保存当前工作</h3><p>保存</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git stash</span><br></pre></td></tr></table></figure><p>查看保存列表</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git stash list</span><br></pre></td></tr></table></figure><p>应用某个存储</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git stash apply stash@&#123;0&#125;</span><br></pre></td></tr></table></figure><p>丢弃某个存储</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git stash drop stash@&#123;0&#125;</span><br></pre></td></tr></table></figure><p>应用并删除</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git stash pop</span><br></pre></td></tr></table></figure><p>删除所有stash</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git stash clear</span><br></pre></td></tr></table></figure><h3 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a>远程仓库</h3><p>添加自己的远程仓库</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add origin url</span><br></pre></td></tr></table></figure><p>添加别人的远程仓库</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add upstream url</span><br></pre></td></tr></table></figure><p>删除远程仓库</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote remove origin/upstream</span><br></pre></td></tr></table></figure><p>查看远程库信息</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote -v</span><br></pre></td></tr></table></figure><h3 id="推送分支"><a href="#推送分支" class="headerlink" title="推送分支"></a>推送分支</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git push -u origin master    <span class="comment">#第一次</span></span><br><span class="line">git push origin master</span><br></pre></td></tr></table></figure><h3 id="删除远程分支"><a href="#删除远程分支" class="headerlink" title="删除远程分支"></a>删除远程分支</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin --delete dev</span><br></pre></td></tr></table></figure><h3 id="从远程仓库克隆（只会克隆master）"><a href="#从远程仓库克隆（只会克隆master）" class="headerlink" title="从远程仓库克隆（只会克隆master）"></a>从远程仓库克隆（只会克隆master）</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> SSH/HTTPS</span><br></pre></td></tr></table></figure><h3 id="创建远程仓库的dev分支到本地"><a href="#创建远程仓库的dev分支到本地" class="headerlink" title="创建远程仓库的dev分支到本地"></a>创建远程仓库的dev分支到本地</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git switch -c dev origin/dev</span><br></pre></td></tr></table></figure><h3 id="拉取远程仓库内容"><a href="#拉取远程仓库内容" class="headerlink" title="拉取远程仓库内容"></a>拉取远程仓库内容</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git fetch origin master    <span class="comment">#只拉取，不合并    </span></span><br><span class="line">git pull origin master    <span class="comment">#拉取（fetch）+合并（merge）  </span></span><br></pre></td></tr></table></figure><h3 id="变基"><a href="#变基" class="headerlink" title="变基"></a>变基</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git rebase upstream/master</span><br><span class="line">若有冲突，解决后  git add</span><br><span class="line">然后执行 git rebase --<span class="built_in">continue</span></span><br></pre></td></tr></table></figure><h3 id="一些参数的解释"><a href="#一些参数的解释" class="headerlink" title="一些参数的解释"></a>一些参数的解释</h3><ul><li><p>-d    –delete：删除</p></li><li><p>-D    –delete –force的快捷键</p></li><li><p>-f      –force：强制</p></li><li><p>-m   –move：移动或重命名</p></li><li><p>-M    –move –force的快捷键</p></li><li><p>-r     –remote：远程</p></li><li><p>-a    –all:所有</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;配置用户名、用户邮箱&quot;&gt;&lt;a href=&quot;#配置用户名、用户邮箱&quot; class=&quot;headerlink&quot; title=&quot;配置用户名、用户邮箱&quot;&gt;&lt;/a&gt;配置用户名、用户邮箱&lt;/h3&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr</summary>
      
    
    
    
    
    <category term="git" scheme="https://xielingfan.github.io/tags/git/"/>
    
  </entry>
  
</feed>
